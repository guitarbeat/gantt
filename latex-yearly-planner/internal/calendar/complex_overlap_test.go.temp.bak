package calendar

import (
	"testing"
	"time"

	"latex-yearly-planner/internal/data"
)

func TestComplexOverlapScenarios(t *testing.T) {
	// Create test calendar range
	calendarStart := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	calendarEnd := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)
	
	// Create overlap detector
	overlapDetector := NewOverlapDetector(calendarStart, calendarEnd)
	
	// Create conflict categorizer
	conflictCategorizer := NewConflictCategorizer(overlapDetector)
	
	// Create priority ranker
	priorityRanker := NewPriorityRanker(conflictCategorizer)
	
	// Test Scenario 1: Multiple overlapping tasks with same assignee
	t.Run("MultipleOverlappingSameAssignee", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Dissertation Chapter 1",
				StartDate: time.Date(2024, 1, 5, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  5,
				Assignee:  "John Doe",
				IsMilestone: true,
			},
			{
				ID:        "task2",
				Name:      "Proposal Writing",
				StartDate: time.Date(2024, 1, 10, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC),
				Category:  "PROPOSAL",
				Priority:  4,
				Assignee:  "John Doe", // Same assignee
			},
			{
				ID:        "task3",
				Name:      "Laser Experiment",
				StartDate: time.Date(2024, 1, 12, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 1, 18, 0, 0, 0, 0, time.UTC),
				Category:  "LASER",
				Priority:  3,
				Assignee:  "John Doe", // Same assignee
			},
		}
		
		// Detect overlaps
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Verify overlaps are detected
		if overlapAnalysis.TotalOverlaps == 0 {
			t.Error("Expected overlaps to be detected")
		}
		
		// Categorize conflicts
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Verify conflicts are categorized
		if len(conflictAnalysis.CategorizedConflicts) == 0 {
			t.Error("Expected conflicts to be categorized")
		}
		
		// Check for assignee conflicts
		assigneeConflicts := conflictAnalysis.GetConflictsByCategory(CategoryAssigneeConflict)
		if len(assigneeConflicts) == 0 {
			t.Error("Expected assignee conflicts to be detected")
		}
		
		// Rank tasks
		context := &PriorityContext{
			CalendarStart:      calendarStart,
			CalendarEnd:        calendarEnd,
			CurrentTime:        time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			AssigneeWorkloads:  map[string]int{"John Doe": 3},
			CategoryImportance: map[string]float64{"DISSERTATION": 10.0, "PROPOSAL": 8.0, "LASER": 5.0},
		}
		
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		
		// Verify tasks are ranked
		if len(priorityRanking.TaskPriorities) != len(tasks) {
			t.Errorf("Expected %d task priorities, got %d", len(tasks), len(priorityRanking.TaskPriorities))
		}
		
		// Verify highest priority task (dissertation milestone)
		if priorityRanking.TaskPriorities[0].Task.ID != "task1" {
			t.Error("Expected dissertation milestone to have highest priority")
		}
		
		// Verify visual prominence
		if priorityRanking.TaskPriorities[0].VisualProminence != ProminenceCritical {
			t.Error("Expected dissertation milestone to have critical prominence")
		}
	})
	
	// Test Scenario 2: Nested and partial overlaps
	t.Run("NestedAndPartialOverlaps", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Long Project",
				StartDate: time.Date(2024, 2, 1, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 2, 28, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  3,
				Assignee:  "Jane Doe",
			},
			{
				ID:        "task2",
				Name:      "Nested Task",
				StartDate: time.Date(2024, 2, 10, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 2, 20, 0, 0, 0, 0, time.UTC),
				Category:  "PROPOSAL",
				Priority:  4,
				Assignee:  "Bob Smith",
			},
			{
				ID:        "task3",
				Name:      "Partial Overlap",
				StartDate: time.Date(2024, 2, 15, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 2, 25, 0, 0, 0, 0, time.UTC),
				Category:  "LASER",
				Priority:  2,
				Assignee:  "Alice Johnson",
			},
		}
		
		// Detect overlaps
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Verify overlaps are detected
		if overlapAnalysis.TotalOverlaps == 0 {
			t.Error("Expected overlaps to be detected")
		}
		
		// Categorize conflicts
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Verify conflicts are categorized
		if len(conflictAnalysis.CategorizedConflicts) == 0 {
			t.Error("Expected conflicts to be categorized")
		}
		
		// Check for different overlap types
		hasNested := false
		hasPartial := false
		for _, conflict := range conflictAnalysis.CategorizedConflicts {
			if conflict.OverlapType == OverlapNested {
				hasNested = true
			}
			if conflict.OverlapType == OverlapPartial {
				hasPartial = true
			}
		}
		
		if !hasNested {
			t.Error("Expected nested overlaps to be detected")
		}
		
		if !hasPartial {
			t.Error("Expected partial overlaps to be detected")
		}
	})
	
	// Test Scenario 3: Identical tasks (critical conflict)
	t.Run("IdenticalTasks", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Identical Task 1",
				StartDate: time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 3, 5, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  4,
				Assignee:  "John Doe",
			},
			{
				ID:        "task2",
				Name:      "Identical Task 2",
				StartDate: time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 3, 5, 0, 0, 0, 0, time.UTC),
				Category:  "PROPOSAL",
				Priority:  4,
				Assignee:  "Jane Doe",
			},
		}
		
		// Detect overlaps
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Verify overlaps are detected
		if overlapAnalysis.TotalOverlaps == 0 {
			t.Error("Expected overlaps to be detected")
		}
		
		// Categorize conflicts
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Verify conflicts are categorized
		if len(conflictAnalysis.CategorizedConflicts) == 0 {
			t.Error("Expected conflicts to be categorized")
		}
		
		// Check for identical overlap type
		hasIdentical := false
		for _, conflict := range conflictAnalysis.CategorizedConflicts {
			if conflict.OverlapType == OverlapIdentical {
				hasIdentical = true
				break
			}
		}
		
		if !hasIdentical {
			t.Error("Expected identical overlaps to be detected")
		}
		
		// Check for critical severity
		criticalConflicts := conflictAnalysis.GetConflictsBySeverity(SeverityCritical)
		if len(criticalConflicts) == 0 {
			t.Error("Expected critical conflicts for identical tasks")
		}
	})
	
	// Test Scenario 4: Dependency conflicts
	t.Run("DependencyConflicts", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Prerequisite Task",
				StartDate: time.Date(2024, 4, 1, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 4, 10, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  3,
				Assignee:  "John Doe",
			},
			{
				ID:        "task2",
				Name:      "Dependent Task",
				StartDate: time.Date(2024, 4, 5, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 4, 15, 0, 0, 0, 0, time.UTC),
				Category:  "PROPOSAL",
				Priority:  4,
				Assignee:  "Jane Doe",
				Dependencies: []string{"task1"}, // Depends on task1
			},
		}
		
		// Detect overlaps
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Verify overlaps are detected
		if overlapAnalysis.TotalOverlaps == 0 {
			t.Error("Expected overlaps to be detected")
		}
		
		// Categorize conflicts
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Verify conflicts are categorized
		if len(conflictAnalysis.CategorizedConflicts) == 0 {
			t.Error("Expected conflicts to be categorized")
		}
		
		// Check for dependency conflicts
		dependencyConflicts := conflictAnalysis.GetConflictsByCategory(CategoryDependencyConflict)
		if len(dependencyConflicts) == 0 {
			t.Error("Expected dependency conflicts to be detected")
		}
	})
	
	// Test Scenario 5: High workload assignee
	t.Run("HighWorkloadAssignee", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Task 1",
				StartDate: time.Date(2024, 5, 1, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 5, 5, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  3,
				Assignee:  "Overloaded Person",
			},
			{
				ID:        "task2",
				Name:      "Task 2",
				StartDate: time.Date(2024, 5, 3, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 5, 7, 0, 0, 0, 0, time.UTC),
				Category:  "PROPOSAL",
				Priority:  4,
				Assignee:  "Overloaded Person", // Same overloaded person
			},
			{
				ID:        "task3",
				Name:      "Task 3",
				StartDate: time.Date(2024, 5, 4, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 5, 8, 0, 0, 0, 0, time.UTC),
				Category:  "LASER",
				Priority:  2,
				Assignee:  "Overloaded Person", // Same overloaded person
			},
		}
		
		// Create context with high workload
		context := &PriorityContext{
			CalendarStart:      calendarStart,
			CalendarEnd:        calendarEnd,
			CurrentTime:        time.Date(2024, 5, 1, 0, 0, 0, 0, time.UTC),
			AssigneeWorkloads:  map[string]int{"Overloaded Person": 8}, // High workload
			CategoryImportance: map[string]float64{"DISSERTATION": 10.0, "PROPOSAL": 8.0, "LASER": 5.0},
		}
		
		// Detect overlaps
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Categorize conflicts
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Rank tasks
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		
		// Verify high workload is considered in ranking
		hasHighWorkloadPriority := false
		for _, taskPriority := range priorityRanking.TaskPriorities {
			if taskPriority.ResourceContention > 3.0 {
				hasHighWorkloadPriority = true
				break
			}
		}
		
		if !hasHighWorkloadPriority {
			t.Error("Expected high workload to be considered in priority ranking")
		}
	})
	
	// Test Scenario 6: Deadline urgency
	t.Run("DeadlineUrgency", func(t *testing.T) {
		now := time.Date(2024, 6, 1, 0, 0, 0, 0, time.UTC)
		
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Urgent Task",
				StartDate: now.AddDate(0, 0, 1), // Starts tomorrow
				EndDate:   now.AddDate(0, 0, 3), // Due in 3 days
				Category:  "DISSERTATION",
				Priority:  4,
				Assignee:  "John Doe",
			},
			{
				ID:        "task2",
				Name:      "Less Urgent Task",
				StartDate: now.AddDate(0, 0, 2), // Starts day after tomorrow
				EndDate:   now.AddDate(0, 0, 4), // Due in 4 days
				Category:  "PROPOSAL",
				Priority:  3,
				Assignee:  "Jane Doe",
			},
		}
		
		// Create context
		context := &PriorityContext{
			CalendarStart:      calendarStart,
			CalendarEnd:        calendarEnd,
			CurrentTime:        now,
			AssigneeWorkloads:  map[string]int{"John Doe": 2, "Jane Doe": 2},
			CategoryImportance: map[string]float64{"DISSERTATION": 10.0, "PROPOSAL": 8.0},
		}
		
		// Detect overlaps
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Categorize conflicts
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Rank tasks
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		
		// Verify urgent task has higher priority
		if priorityRanking.TaskPriorities[0].Task.ID != "task1" {
			t.Error("Expected urgent task to have higher priority")
		}
		
		// Verify timeline urgency is high
		if priorityRanking.TaskPriorities[0].TimelineUrgency < 8.0 {
			t.Error("Expected high timeline urgency for urgent task")
		}
	})
}

func TestComplexOverlapIntegration(t *testing.T) {
	// Create test calendar range
	calendarStart := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	calendarEnd := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)
	
	// Create all components
	overlapDetector := NewOverlapDetector(calendarStart, calendarEnd)
	conflictCategorizer := NewConflictCategorizer(overlapDetector)
	priorityRanker := NewPriorityRanker(conflictCategorizer)
	
	// Create complex scenario with multiple overlapping tasks
	tasks := []*data.Task{
		{
			ID:        "dissertation_chapter_1",
			Name:      "Dissertation Chapter 1",
			StartDate: time.Date(2024, 1, 5, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC),
			Category:  "DISSERTATION",
			Priority:  5,
			Assignee:  "John Doe",
			IsMilestone: true,
		},
		{
			ID:        "proposal_writing",
			Name:      "Proposal Writing",
			StartDate: time.Date(2024, 1, 10, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 1, 25, 0, 0, 0, 0, time.UTC),
			Category:  "PROPOSAL",
			Priority:  4,
			Assignee:  "John Doe", // Same assignee
		},
		{
			ID:        "laser_experiment",
			Name:      "Laser Experiment",
			StartDate: time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 1, 22, 0, 0, 0, 0, time.UTC),
			Category:  "LASER",
			Priority:  3,
			Assignee:  "Jane Doe",
		},
		{
			ID:        "meeting_prep",
			Name:      "Meeting Preparation",
			StartDate: time.Date(2024, 1, 18, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC),
			Category:  "MEETING",
			Priority:  2,
			Assignee:  "Bob Smith",
		},
		{
			ID:        "admin_task",
			Name:      "Administrative Task",
			StartDate: time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 1, 22, 0, 0, 0, 0, time.UTC),
			Category:  "ADMIN",
			Priority:  1,
			Assignee:  "Alice Johnson",
		},
	}
	
	// Create context
	context := &PriorityContext{
		CalendarStart:      calendarStart,
		CalendarEnd:        calendarEnd,
		CurrentTime:        time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
		AssigneeWorkloads:  map[string]int{"John Doe": 3, "Jane Doe": 2, "Bob Smith": 1, "Alice Johnson": 1},
		CategoryImportance: map[string]float64{"DISSERTATION": 10.0, "PROPOSAL": 8.0, "LASER": 5.0, "MEETING": 3.0, "ADMIN": 1.0},
	}
	
	// Step 1: Detect overlaps
	overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
	
	// Verify overlap detection
	if overlapAnalysis.TotalOverlaps == 0 {
		t.Error("Expected overlaps to be detected in complex scenario")
	}
	
	// Step 2: Categorize conflicts
	conflictAnalysis := conflictCategorizer.CategorizeConflicts(overlapAnalysis)
	
	// Verify conflict categorization
	if len(conflictAnalysis.CategorizedConflicts) == 0 {
		t.Error("Expected conflicts to be categorized in complex scenario")
	}
	
	// Step 3: Rank tasks
	priorityRanking := priorityRanker.RankTasks(tasks, context)
	
	// Verify priority ranking
	if len(priorityRanking.TaskPriorities) != len(tasks) {
		t.Errorf("Expected %d task priorities, got %d", len(tasks), len(priorityRanking.TaskPriorities))
	}
	
	// Verify dissertation milestone has highest priority
	if priorityRanking.TaskPriorities[0].Task.ID != "dissertation_chapter_1" {
		t.Error("Expected dissertation milestone to have highest priority")
	}
	
	// Verify visual prominence hierarchy
	expectedProminence := []VisualProminence{ProminenceCritical, ProminenceHigh, ProminenceMedium, ProminenceLow, ProminenceMinimal}
	for i, taskPriority := range priorityRanking.TaskPriorities {
		if i < len(expectedProminence) {
			if taskPriority.VisualProminence != expectedProminence[i] {
				t.Errorf("Expected prominence %s for task %d, got %s", expectedProminence[i], i, taskPriority.VisualProminence)
			}
		}
	}
	
	// Verify recommendations are generated
	if len(priorityRanking.Recommendations) == 0 {
		t.Error("Expected recommendations to be generated")
	}
	
	// Verify conflict analysis summary
	summary := conflictAnalysis.GetSummary()
	if summary == "" {
		t.Error("Expected conflict analysis summary")
	}
	
	// Verify priority ranking summary
	rankingSummary := priorityRanking.GetSummary()
	if rankingSummary == "" {
		t.Error("Expected priority ranking summary")
	}
	
	// Verify critical tasks are identified
	if len(priorityRanking.CriticalTasks) == 0 {
		t.Error("Expected critical tasks to be identified")
	}
	
	// Verify visual hierarchy is generated
	if len(priorityRanking.VisualHierarchy) != len(tasks) {
		t.Errorf("Expected %d tasks in visual hierarchy, got %d", len(tasks), len(priorityRanking.VisualHierarchy))
	}
}

func TestEdgeCases(t *testing.T) {
	// Create test calendar range
	calendarStart := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	calendarEnd := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)
	
	// Create all components
	overlapDetector := NewOverlapDetector(calendarStart, calendarEnd)
	conflictCategorizer := NewConflictCategorizer(overlapDetector)
	priorityRanker := NewPriorityRanker(conflictCategorizer)
	
	// Test with empty task list
	t.Run("EmptyTaskList", func(t *testing.T) {
		tasks := []*data.Task{}
		
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		if overlapAnalysis.TotalOverlaps != 0 {
			t.Error("Expected no overlaps for empty task list")
		}
		
		conflictAnalysis := conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		if len(conflictAnalysis.CategorizedConflicts) != 0 {
			t.Error("Expected no conflicts for empty task list")
		}
		
		context := &PriorityContext{
			CalendarStart:      calendarStart,
			CalendarEnd:        calendarEnd,
			CurrentTime:        time.Now(),
			AssigneeWorkloads:  map[string]int{},
			CategoryImportance: map[string]float64{},
		}
		
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		if len(priorityRanking.TaskPriorities) != 0 {
			t.Error("Expected no task priorities for empty task list")
		}
	})
	
	// Test with single task
	t.Run("SingleTask", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Single Task",
				StartDate: time.Date(2024, 1, 5, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 1, 10, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  3,
				Assignee:  "John Doe",
			},
		}
		
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		if overlapAnalysis.TotalOverlaps != 0 {
			t.Error("Expected no overlaps for single task")
		}
		
		conflictAnalysis := conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		if len(conflictAnalysis.CategorizedConflicts) != 0 {
			t.Error("Expected no conflicts for single task")
		}
		
		context := &PriorityContext{
			CalendarStart:      calendarStart,
			CalendarEnd:        calendarEnd,
			CurrentTime:        time.Now(),
			AssigneeWorkloads:  map[string]int{"John Doe": 1},
			CategoryImportance: map[string]float64{"DISSERTATION": 10.0},
		}
		
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		if len(priorityRanking.TaskPriorities) != 1 {
			t.Error("Expected one task priority for single task")
		}
	})
	
	// Test with non-overlapping tasks
	t.Run("NonOverlappingTasks", func(t *testing.T) {
		tasks := []*data.Task{
			{
				ID:        "task1",
				Name:      "Task 1",
				StartDate: time.Date(2024, 1, 5, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 1, 10, 0, 0, 0, 0, time.UTC),
				Category:  "DISSERTATION",
				Priority:  3,
				Assignee:  "John Doe",
			},
			{
				ID:        "task2",
				Name:      "Task 2",
				StartDate: time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
				EndDate:   time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC),
				Category:  "PROPOSAL",
				Priority:  4,
				Assignee:  "Jane Doe",
			},
		}
		
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		if overlapAnalysis.TotalOverlaps != 0 {
			t.Error("Expected no overlaps for non-overlapping tasks")
		}
		
		conflictAnalysis := conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		if len(conflictAnalysis.CategorizedConflicts) != 0 {
			t.Error("Expected no conflicts for non-overlapping tasks")
		}
		
		context := &PriorityContext{
			CalendarStart:      calendarStart,
			CalendarEnd:        calendarEnd,
			CurrentTime:        time.Now(),
			AssigneeWorkloads:  map[string]int{"John Doe": 1, "Jane Doe": 1},
			CategoryImportance: map[string]float64{"DISSERTATION": 10.0, "PROPOSAL": 8.0},
		}
		
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		if len(priorityRanking.TaskPriorities) != 2 {
			t.Error("Expected two task priorities for two tasks")
		}
	})
}
