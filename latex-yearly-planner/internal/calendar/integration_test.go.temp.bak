package calendar

import (
	"fmt"
	"testing"
	"time"

	"latex-yearly-planner/internal/data"
)

func TestOverlapDetectionSystemIntegration(t *testing.T) {
	// Create test calendar range for the year 2024
	calendarStart := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	calendarEnd := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)
	
	// Create all system components
	overlapDetector := NewOverlapDetector(calendarStart, calendarEnd)
	conflictCategorizer := NewConflictCategorizer(overlapDetector)
	priorityRanker := NewPriorityRanker(conflictCategorizer)
	
	// Create comprehensive test dataset representing real-world scenarios
	tasks := []*data.Task{
		// Dissertation milestones (highest priority)
		{
			ID:        "diss_chapter_1",
			Name:      "Dissertation Chapter 1: Literature Review",
			StartDate: time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 3, 15, 0, 0, 0, 0, time.UTC),
			Category:  "DISSERTATION",
			Priority:  5,
			Assignee:  "Aaron",
			IsMilestone: true,
			Dependencies: []string{},
		},
		{
			ID:        "diss_chapter_2",
			Name:      "Dissertation Chapter 2: Methodology",
			StartDate: time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 5, 1, 0, 0, 0, 0, time.UTC),
			Category:  "DISSERTATION",
			Priority:  5,
			Assignee:  "Aaron",
			IsMilestone: true,
			Dependencies: []string{"diss_chapter_1"},
		},
		
		// Proposal work (high priority, overlapping with dissertation)
		{
			ID:        "proposal_draft",
			Name:      "Grant Proposal Draft",
			StartDate: time.Date(2024, 2, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 4, 1, 0, 0, 0, 0, time.UTC),
			Category:  "PROPOSAL",
			Priority:  4,
			Assignee:  "Aaron", // Same assignee - conflict
			Dependencies: []string{},
		},
		{
			ID:        "proposal_review",
			Name:      "Proposal Review and Revision",
			StartDate: time.Date(2024, 3, 15, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 4, 15, 0, 0, 0, 0, time.UTC),
			Category:  "PROPOSAL",
			Priority:  4,
			Assignee:  "Aaron", // Same assignee - conflict
			Dependencies: []string{"proposal_draft"},
		},
		
		// Laser experiments (medium priority, some overlaps)
		{
			ID:        "laser_setup",
			Name:      "Laser System Setup",
			StartDate: time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 2, 20, 0, 0, 0, 0, time.UTC),
			Category:  "LASER",
			Priority:  3,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
		{
			ID:        "laser_experiment_1",
			Name:      "Laser Experiment 1: Initial Tests",
			StartDate: time.Date(2024, 2, 15, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 3, 15, 0, 0, 0, 0, time.UTC),
			Category:  "LASER",
			Priority:  3,
			Assignee:  "Aaron", // Same assignee - conflict
			Dependencies: []string{"laser_setup"},
		},
		{
			ID:        "laser_experiment_2",
			Name:      "Laser Experiment 2: Advanced Tests",
			StartDate: time.Date(2024, 4, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 5, 1, 0, 0, 0, 0, time.UTC),
			Category:  "LASER",
			Priority:  3,
			Assignee:  "Aaron",
			Dependencies: []string{"laser_experiment_1"},
		},
		
		// Meetings and administrative tasks (lower priority)
		{
			ID:        "lab_meeting_prep",
			Name:      "Lab Meeting Preparation",
			StartDate: time.Date(2024, 2, 28, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC),
			Category:  "MEETING",
			Priority:  2,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
		{
			ID:        "admin_paperwork",
			Name:      "Administrative Paperwork",
			StartDate: time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 3, 3, 0, 0, 0, 0, time.UTC),
			Category:  "ADMIN",
			Priority:  1,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
		
		// Identical tasks (critical conflict)
		{
			ID:        "identical_task_1",
			Name:      "Identical Task 1",
			StartDate: time.Date(2024, 6, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 6, 5, 0, 0, 0, 0, time.UTC),
			Category:  "DISSERTATION",
			Priority:  4,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
		{
			ID:        "identical_task_2",
			Name:      "Identical Task 2",
			StartDate: time.Date(2024, 6, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 6, 5, 0, 0, 0, 0, time.UTC),
			Category:  "PROPOSAL",
			Priority:  4,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
		
		// Nested tasks
		{
			ID:        "long_project",
			Name:      "Long-term Project",
			StartDate: time.Date(2024, 7, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 9, 30, 0, 0, 0, 0, time.UTC),
			Category:  "DISSERTATION",
			Priority:  3,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
		{
			ID:        "nested_task",
			Name:      "Nested Task",
			StartDate: time.Date(2024, 8, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 8, 15, 0, 0, 0, 0, time.UTC),
			Category:  "LASER",
			Priority:  2,
			Assignee:  "Aaron",
			Dependencies: []string{},
		},
	}
	
	// Create context with realistic workload and importance
	context := &PriorityContext{
		CalendarStart:      calendarStart,
		CalendarEnd:        calendarEnd,
		CurrentTime:        time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
		AssigneeWorkloads:  map[string]int{"Aaron": 8}, // High workload
		CategoryImportance: map[string]float64{
			"DISSERTATION": 10.0,
			"PROPOSAL":     8.0,
			"LASER":        5.0,
			"MEETING":      3.0,
			"ADMIN":        1.0,
		},
	}
	
	// Step 1: Detect Overlaps
	t.Run("OverlapDetection", func(t *testing.T) {
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		
		// Verify overlaps are detected
		if overlapAnalysis.TotalOverlaps == 0 {
			t.Error("Expected overlaps to be detected in comprehensive scenario")
		}
		
		// Verify overlap groups are created
		if len(overlapAnalysis.OverlapGroups) == 0 {
			t.Error("Expected overlap groups to be created")
		}
		
		// Verify critical overlaps are identified
		if overlapAnalysis.CriticalOverlaps == 0 {
			t.Error("Expected critical overlaps to be identified")
		}
		
		// Verify summary is generated
		if overlapAnalysis.Summary == "" {
			t.Error("Expected overlap analysis summary")
		}
	})
	
	// Step 2: Categorize Conflicts
	t.Run("ConflictCategorization", func(t *testing.T) {
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		
		// Verify conflicts are categorized
		if len(conflictAnalysis.CategorizedConflicts) == 0 {
			t.Error("Expected conflicts to be categorized")
		}
		
		// Verify different conflict categories are detected
		categories := make(map[ConflictCategory]bool)
		for _, conflict := range conflictAnalysis.CategorizedConflicts {
			categories[conflict.Category] = true
		}
		
		expectedCategories := []ConflictCategory{
			CategoryScheduleConflict,
			CategoryAssigneeConflict,
			CategoryPriorityConflict,
			CategoryCategoryConflict,
		}
		
		for _, expectedCategory := range expectedCategories {
			if !categories[expectedCategory] {
				t.Errorf("Expected conflict category %s to be detected", expectedCategory)
			}
		}
		
		// Verify severity distribution
		if conflictAnalysis.ConflictsBySeverity[SeverityCritical] == 0 {
			t.Error("Expected critical conflicts to be detected")
		}
		
		// Verify risk assessment
		if conflictAnalysis.RiskAssessment == "" {
			t.Error("Expected risk assessment to be generated")
		}
		
		// Verify recommendations
		if len(conflictAnalysis.Recommendations) == 0 {
			t.Error("Expected recommendations to be generated")
		}
	})
	
	// Step 3: Priority Ranking
	t.Run("PriorityRanking", func(t *testing.T) {
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		
		// Verify all tasks are ranked
		if len(priorityRanking.TaskPriorities) != len(tasks) {
			t.Errorf("Expected %d task priorities, got %d", len(tasks), len(priorityRanking.TaskPriorities))
		}
		
		// Verify tasks are sorted by priority (highest first)
		for i := 1; i < len(priorityRanking.TaskPriorities); i++ {
			if priorityRanking.TaskPriorities[i-1].PriorityScore < priorityRanking.TaskPriorities[i].PriorityScore {
				t.Error("Expected tasks to be sorted by priority score (highest first)")
			}
		}
		
		// Verify dissertation milestones have highest priority
		topTask := priorityRanking.TaskPriorities[0]
		if topTask.Task.Category != "DISSERTATION" || !topTask.Task.IsMilestone {
			t.Error("Expected dissertation milestone to have highest priority")
		}
		
		// Verify visual prominence hierarchy
		prominenceCounts := make(map[VisualProminence]int)
		for _, taskPriority := range priorityRanking.TaskPriorities {
			prominenceCounts[taskPriority.VisualProminence]++
		}
		
		// Should have critical tasks
		if prominenceCounts[ProminenceCritical] == 0 {
			t.Error("Expected critical tasks to be identified")
		}
		
		// Verify visual hierarchy is generated
		if len(priorityRanking.VisualHierarchy) != len(tasks) {
			t.Errorf("Expected %d tasks in visual hierarchy, got %d", len(tasks), len(priorityRanking.VisualHierarchy))
		}
		
		// Verify recommendations are generated
		if len(priorityRanking.Recommendations) == 0 {
			t.Error("Expected recommendations to be generated")
		}
	})
	
	// Step 4: Complete System Integration
	t.Run("CompleteSystemIntegration", func(t *testing.T) {
		// Run complete pipeline
		overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
		_ = conflictCategorizer.CategorizeConflicts(overlapAnalysis)
		priorityRanking := priorityRanker.RankTasks(tasks, context)
		
		// Verify system integration
		if overlapAnalysis.TotalOverlaps == 0 {
			t.Error("Expected overlaps to be detected")
		}
		
		if len(conflictAnalysis.CategorizedConflicts) == 0 {
			t.Error("Expected conflicts to be categorized")
		}
		
		if len(priorityRanking.TaskPriorities) != len(tasks) {
			t.Error("Expected all tasks to be ranked")
		}
		
		// Verify critical tasks are properly identified
		criticalTasks := priorityRanking.GetTasksByProminence(ProminenceCritical)
		if len(criticalTasks) == 0 {
			t.Error("Expected critical tasks to be identified")
		}
		
		// Verify high priority tasks
		highTasks := priorityRanking.GetTasksByProminence(ProminenceHigh)
		if len(highTasks) == 0 {
			t.Error("Expected high priority tasks to be identified")
		}
		
		// Verify conflict resolution strategies
		hasResolutionStrategies := false
		for _, conflict := range conflictAnalysis.CategorizedConflicts {
			if conflict.Resolution.Strategy != "" {
				hasResolutionStrategies = true
				break
			}
		}
		
		if !hasResolutionStrategies {
			t.Error("Expected conflict resolution strategies to be generated")
		}
		
		// Verify visual styling
		hasVisualStyling := false
		for _, taskPriority := range priorityRanking.TaskPriorities {
			if taskPriority.VisualStyle.BorderColor != "" {
				hasVisualStyling = true
				break
			}
		}
		
		if !hasVisualStyling {
			t.Error("Expected visual styling to be generated")
		}
		
		// Verify comprehensive reporting
		if overlapAnalysis.Summary == "" {
			t.Error("Expected overlap analysis summary")
		}
		
		conflictSummary := conflictAnalysis.GetSummary()
		if conflictSummary == "" {
			t.Error("Expected conflict analysis summary")
		}
		
		rankingSummary := priorityRanking.GetSummary()
		if rankingSummary == "" {
			t.Error("Expected priority ranking summary")
		}
	})
}

func TestSystemPerformance(t *testing.T) {
	// Create test calendar range
	calendarStart := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	calendarEnd := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)
	
	// Create all components
	overlapDetector := NewOverlapDetector(calendarStart, calendarEnd)
	conflictCategorizer := NewConflictCategorizer(overlapDetector)
	priorityRanker := NewPriorityRanker(conflictCategorizer)
	
	// Create large dataset for performance testing
	var tasks []*data.Task
	for i := 0; i < 100; i++ {
		task := &data.Task{
			ID:        fmt.Sprintf("task_%d", i),
			Name:      fmt.Sprintf("Task %d", i),
			StartDate: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC).AddDate(0, 0, i*3),
			EndDate:   time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC).AddDate(0, 0, i*3+2),
			Category:  "DISSERTATION",
			Priority:  (i % 5) + 1,
			Assignee:  "Aaron",
		}
		tasks = append(tasks, task)
	}
	
	// Create context
	context := &PriorityContext{
		CalendarStart:      calendarStart,
		CalendarEnd:        calendarEnd,
		CurrentTime:        time.Now(),
		AssigneeWorkloads:  map[string]int{"Aaron": 5},
		CategoryImportance: map[string]float64{"DISSERTATION": 10.0},
	}
	
	// Measure performance
	start := time.Now()
	
	// Run complete pipeline
	overlapAnalysis := overlapDetector.DetectOverlaps(tasks)
	conflictAnalysis := conflictCategorizer.CategorizeConflicts(overlapAnalysis)
	priorityRanking := priorityRanker.RankTasks(tasks, context)
	
	duration := time.Since(start)
	
	// Verify results
	if len(priorityRanking.TaskPriorities) != len(tasks) {
		t.Error("Expected all tasks to be processed")
	}
	
	// Performance should be reasonable (less than 1 second for 100 tasks)
	if duration > time.Second {
		t.Errorf("Performance test took too long: %v", duration)
	}
	
	t.Logf("Processed %d tasks in %v", len(tasks), duration)
}
