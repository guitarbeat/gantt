#!/usr/bin/env python3
"""
LaTeX generation components for the Gantt chart generator.
Provides modular LaTeX generation for different document sections.
"""

from typing import List
from datetime import date, timedelta

from .models import Task, ProjectTimeline, MonthInfo
from .config import config


class LaTeXEscaper:
    """Handles LaTeX character escaping and text formatting."""

    @staticmethod
    def escape_latex(text: str) -> str:
        """Escape special LaTeX characters in text."""
        if not text:
            return ""

        # Handle backslashes first to avoid double-escaping
        text = text.replace('\\', r'\textbackslash{}')

        # Handle Unicode characters
        unicode_replacements = {
            '≥': r'$\geq$',
            '≤': r'$\leq$',
            '≠': r'$\neq$',
            '±': r'$\pm$',
            '×': r'$\times$',
            '÷': r'$\div$',
            '∞': r'$\infty$',
            'α': r'$\alpha$',
            'β': r'$\beta$',
            'γ': r'$\gamma$',
            'δ': r'$\delta$',
            'ε': r'$\varepsilon$',
            'θ': r'$\theta$',
            'λ': r'$\lambda$',
            'μ': r'$\mu$',
            'π': r'$\pi$',
            'σ': r'$\sigma$',
            'τ': r'$\tau$',
            'φ': r'$\phi$',
            'χ': r'$\chi$',
            'ψ': r'$\psi$',
            'ω': r'$\omega$',
        }

        for char, replacement in unicode_replacements.items():
            text = text.replace(char, replacement)

        # Handle other special characters
        replacements = {
            '&': r'\&',
            '%': r'\%',
            '$': r'\$',
            '#': r'\#',
            '^': r'\textasciicircum{}',
            '_': r'\_',
            '{': r'\{',
            '}': r'\}',
            '~': r'\textasciitilde{}',
        }

        for char, replacement in replacements.items():
            text = text.replace(char, replacement)

        # Fix any double-escaped characters that might cause issues
        text = text.replace(r'\textbackslash{}\#', r'\#')
        text = text.replace(r'\textbackslash{}\&', r'\&')

        return text


class LaTeXDocumentGenerator:
    """Generates the main LaTeX document structure."""

    def __init__(self, escaper: LaTeXEscaper = None):
        self.escaper = escaper or LaTeXEscaper()

    def generate_document_header(self) -> str:
        """Generate the LaTeX document header with packages and enhanced TikZ libraries."""
        packages = '\n'.join(f"\\usepackage{{{pkg}}}" for pkg in config.latex.packages)
        
        # * Add TikZ libraries for enhanced functionality
        tikz_libraries = '\n'.join(f"\\usetikzlibrary{{{lib}}}" for lib in config.latex.get_tikz_libraries())

        return f"""\\documentclass[{config.calendar.page_orientation},{config.calendar.page_size}]{{{config.latex.document_class}}}
{packages}

% Enhanced TikZ libraries for better graphics
{tikz_libraries}

% Page setup inspired by calendar.sty
\\pagestyle{{empty}}
\\setlength{{\\parskip}}{{0.5em}}

% Table formatting
\\setlength{{\\tabcolsep}}{{1pt}}
\\renewcommand{{\\arraystretch}}{{1.0}}

% Use Helvetica for sans-serif
\\renewcommand{{\\familydefault}}{{\\sfdefault}}

% Enhanced TikZ styles
{self._generate_tikz_styles()}

% Color definitions
{config.colors.to_latex_colors()}

\\begin{{document}}
"""

    def _generate_tikz_styles(self) -> str:
        """Generate enhanced TikZ styles for better graphics."""
        return """
% Enhanced TikZ styles for project timeline
\tikzset{
    % Task node styles
    task node/.style={
        rectangle, 
        rounded corners=2pt,
        draw=black!50,
        fill=white,
        minimum height=0.6cm,
        minimum width=1.5cm,
        font=\\small\\bfseries,
        align=center
    },
    milestone node/.style={
        diamond,
        draw=black!50,
        fill=white,
        minimum size=0.8cm,
        font=\\small\\bfseries,
        align=center
    },
    % Timeline styles
    timeline axis/.style={
        thick,
        line width=2pt,
        color=black!70
    },
    timeline tick/.style={
        thick,
        line width=1pt,
        color=black!50
    },
    % Arrow styles
    dependency arrow/.style={
        ->,
        thick,
        color=black!60,
        line width=1.5pt
    },
    % Calendar styles
    calendar day/.style={
        rectangle,
        draw=black!30,
        fill=white,
        minimum size=1cm,
        font=\\small
    },
    calendar header/.style={
        rectangle,
        draw=black!50,
        fill=black!10,
        minimum height=0.5cm,
        font=\\small\\bfseries
    }
}

% Set background layer
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
"""

    def generate_document_footer(self) -> str:
        """Generate the LaTeX document footer."""
        return "\\end{document}\n"


class TitlePageGenerator:
    """Generates the title page for the LaTeX document."""

    def __init__(self, escaper: LaTeXEscaper = None):
        self.escaper = escaper or LaTeXEscaper()

    def generate_title_page(self, timeline: ProjectTimeline) -> str:
        """Generate the title page for the timeline."""
        title = self.escaper.escape_latex(timeline.title)
        start_date_str = timeline.start_date.strftime('%B %d, %Y')
        end_date_str = timeline.end_date.strftime('%B %d, %Y')

        return f"""
% Title page inspired by calendar.sty
\\begin{{titlepage}}
\\centering
\\vspace*{{{config.calendar.title_spacing}}}

{{{config.calendar.title_font_size}\\textbf{{{title}}}}}

\\vspace{{{config.calendar.month_spacing}}}
{{{config.calendar.month_font_size} {config.latex.subtitle}}}

\\vspace{{{config.calendar.title_spacing}}}

\\begin{{minipage}}{{0.9\\textwidth}}
\\centering
\\textbf{{Timeline Period:}} {start_date_str} -- {end_date_str}\\\\
\\textbf{{Total Duration:}} {timeline.total_duration_days} days\\\\
\\textbf{{Total Tasks:}} {timeline.total_tasks} tasks\\\\
\\textbf{{Months Covered:}} {len(timeline.get_months_between())} months
\\end{{minipage}}

\\vfill

\\end{{titlepage}}
"""

    def generate_month_page(self, month_info: MonthInfo, tasks: List[Task]) -> str:
        """Generate a complete calendar page for a month."""
        if not tasks:
            return ""

        # Create calendar generator for the grid
        calendar_gen = CalendarGenerator(self.escaper)
        
        page = f"""
\\subsection*{{{month_info.start_date.strftime('%B %Y')}}}
\\vspace{{0.5cm}}

{calendar_gen.generate_calendar_grid(month_info, tasks)}
\\vspace{{0.5cm}}
\\subsection{{Task Details for {month_info.start_date.strftime('%B %Y')}}}
\\begin{{itemize}}[leftmargin=1cm, itemsep=0.8em]
"""
        
        for task in tasks:
            task_name = self.escaper.escape_latex(task.name)
            task_description = self.escaper.escape_latex(task.notes) if task.notes else ""
            
            # Enhanced task display with bold name and full description
            page += f"    \\item \\textcolor{{{task.category_color}}}{{\\textbf{{{task_name}}}}}\\\\[0.2em]\n"
            page += f"          \\textcolor{{black!70}}{{\\small {task.start_date.strftime('%m/%d')} to {task.due_date.strftime('%m/%d')}}}\n"
            
            if task_description:
                # Format description with proper line breaks and indentation
                formatted_description = self._format_task_description(task_description)
                page += f"\\\\[0.3em]\n          \\begin{{minipage}}[t]{{0.85\\textwidth}}\n"
                page += f"          \\textcolor{{black!80}}{{{formatted_description}}}\n"
                page += f"          \\end{{minipage}}\n"
            
            page += "\n"
        
        page += "\\end{itemize}\n"
        return page

    def _format_task_description(self, description: str) -> str:
        """Format task description for better readability with proper line breaks."""
        if not description:
            return ""
        
        # Split long descriptions into multiple lines for better readability
        words = description.split()
        lines = []
        current_line = []
        max_words_per_line = 12  # Adjust based on desired line length
        
        for word in words:
            current_line.append(word)
            if len(current_line) >= max_words_per_line:
                lines.append(' '.join(current_line))
                current_line = []
        
        # Add remaining words
        if current_line:
            lines.append(' '.join(current_line))
        
        # Join lines with LaTeX line breaks
        return '\\\\[0.1em]\n          '.join(lines)


class CalendarGenerator:
    """Generates calendar views for the LaTeX document."""

    def __init__(self, escaper: LaTeXEscaper = None):
        self.escaper = escaper or LaTeXEscaper()

    def generate_calendar_grid(self, month_info: MonthInfo, tasks: List[Task]) -> str:
        """Generate the enhanced TikZ calendar grid for a month using modern TikZ features."""
        grid = f"""
% Enhanced calendar grid with modern TikZ features
\begin{tikzpicture}[scale={config.calendar.calendar_scale}]
    % Main calendar border with shadow effect
    \draw[thick, draw=black!50, fill=white, drop shadow={{shadow xshift=2pt, shadow yshift=-2pt, fill=black!20}}]
          (0,0) rectangle ({config.calendar.calendar_width},{config.calendar.calendar_height});

    % Day headers with enhanced styling
    \foreach \day [count=\i] in {{{{Sun, Mon, Tue, Wed, Thu, Fri, Sat}}}} {{ 
        \node[calendar header] at (\i-0.5, 5.5) {{{{\day}}}};
    }} 

    % Grid lines drawn on a background layer to appear behind content
    \begin{pgfonlayer}{background}
        \foreach \x in {{{{1,2,3,4,5,6}}}} {{ 
            \draw[line width=0.5pt, color=black!15] (\x,0) -- (\x,5);
        }}
        \foreach \y in {{{{1,2,3,4,5}}}} {{ 
            \draw[line width=0.5pt, color=black!15] (0,\y) -- ({config.calendar.calendar_width},\y);
        }}
    \end{pgfonlayer}
"

        # Add day numbers and tasks
        current_day = 1
        for week in range(6):  # Maximum 6 weeks
            for day in range(7):  # 7 days per week
                if week == 0 and day < month_info.first_weekday:
                    continue  # Skip days before month starts
                if current_day > month_info.num_days:
                    break

                y_pos = 4.5 - week

                # Add day number
                grid += f"    \\node[font=\\bfseries{{{config.calendar.day_font_size}}}, anchor=north west] at ({{day+0.05}},{{y_pos+0.4}}) {{{current_day}}};\\n"

                # Find tasks for this day
                day_date = month_info.start_date + timedelta(days=current_day - 1)
                day_tasks = [t for t in tasks if t.overlaps_with_date(day_date)]

                # Add task content in the day cell
                if day_tasks:
                    task_text = self._generate_day_task_text(day_tasks)
                    grid += f"    \node[font={{config.calendar.task_font_size}}, anchor=north west, text width=0.9cm] at ({{day+0.05}},{{y_pos-0.1}}) {{{task_text}}};\n"

                current_day += 1
            if current_day > month_info.num_days:
                break

        grid += "\\end{tikzpicture}\n"
        return grid

    def _generate_day_task_text(self, tasks: List[Task]) -> str:
        """Generate task text for a single day cell."""
        task_text = ""
        limited_tasks = tasks[:config.calendar.max_tasks_per_day]

        for i, task in enumerate(limited_tasks):
            task_name = self.escaper.escape_latex(task.name)

            if task.is_milestone:
                task_text += f"\\textcolor{{{task.category_color}}}{{\\textbf{{$\\diamond$ {task_name}}}}}"
            else:
                task_text += f"\\textcolor{{{task.category_color}}}{{\\textbf{{$\\bullet$ {task_name}}}}}"

            if i < len(limited_tasks) - 1:
                task_text += r"[-0.1em]"

        return task_text


class GanttChartGenerator:
    """Generates Gantt charts using the pgfgantt library from awesome-tikz."""

    def __init__(self, escaper: LaTeXEscaper = None):
        self.escaper = escaper or LaTeXEscaper()

    def generate_gantt_chart(self, timeline: ProjectTimeline) -> str:
        """Generate a Gantt chart for the project timeline."""
        gantt = """
% Gantt chart using pgfgantt library
\\begin{ganttchart}[
    hgrid,
    vgrid,
    x unit=0.5cm,
    y unit title=0.6cm,
    y unit chart=0.6cm,
    time slot format=isodate,
    title/.append style={fill=black!10},
    bar/.append style={fill=blue!50, rounded corners=2pt},
    bar incomplete/.append style={fill=red!50},
    milestone/.append style={fill=orange, rounded corners=2pt},
    milestone incomplete/.append style={fill=red!50}
]{\\timeline_start}{\\timeline_end}
\\gantttitlecalendar{year, month} \\\\
"""
        
        # Add tasks to Gantt chart with bold names
        for i, task in enumerate(timeline.tasks):
            task_name = self.escaper.escape_latex(task.name)
            bold_task_name = f"\\textbf{{{task_name}}}"
            start_date = task.start_date.strftime('%Y-%m-%d')
            due_date = task.due_date.strftime('%Y-%m-%d')
            
            if task.is_milestone:
                gantt += f"\\ganttmilestone{{{bold_task_name}}}{{{start_date}}} \\\\\n"
            else:
                gantt += f"\\ganttbar{{{bold_task_name}}}{{{start_date}}}{{{due_date}}} \\\\\n"
        
        gantt += "\\end{ganttchart}\n"
        return gantt

    def generate_timeline_view(self, timeline: ProjectTimeline) -> str:
        """Generate a modern timeline view using enhanced TikZ."""
        timeline_code = """
% Modern timeline view with enhanced TikZ
\\begin{tikzpicture}[scale=0.8]
    % Timeline axis
    \\draw[timeline axis] (0,0) -- (12,0);
    
    % Month markers
    \\foreach \\x/\\month in {0/Aug, 2/Sep, 4/Oct, 6/Nov, 8/Dec, 10/Jan} {
        \\draw[timeline tick] (\\x,0) -- (\\x,-0.3);
        \\node[below, font=\\small] at (\\x,-0.3) {\\month};
    }
    
    % Task bars with enhanced styling
"""
        
        y_pos = 1
        for task in timeline.tasks:
            task_name = self.escaper.escape_latex(task.name)
            bold_task_name = f"\\textbf{{{task_name}}}"
            start_x = self._calculate_timeline_position(task.start_date, timeline.start_date)
            end_x = self._calculate_timeline_position(task.due_date, timeline.start_date)
            
            if task.is_milestone:
                timeline_code += f"    \\node[milestone node, fill={task.category_color}] at ({start_x},{y_pos}) {{{bold_task_name}}};\\n"
            else:
                timeline_code += f"    \\draw[fill={task.category_color}, rounded corners=2pt] ({start_x},{y_pos-0.2}) rectangle ({end_x},{y_pos+0.2}) node[midway, white, font=\\small\\bfseries] {{{task_name}}};\\n"
            
            y_pos += 0.8
        
        timeline_code += "\\end{tikzpicture}\n"
        return timeline_code

    def _calculate_timeline_position(self, date: date, start_date: date) -> float:
        """Calculate the x-position for a date on the timeline."""
        days_diff = (date - start_date).days
        return (days_diff / 30.0) * 2  # Scale to fit 12 units for 6 months


class LegendGenerator:
    """Generates the legend section for the LaTeX document."""

    def __init__(self, escaper: LaTeXEscaper = None):
        self.escaper = escaper or LaTeXEscaper()

    def generate_legend(self) -> str:
        """Generate the complete legend section."""
        return """
% Legend
\\section{Legend}

\\subsection{Task Categories}
\\begin{itemize}[leftmargin=2cm]
    \\item[\\textcolor{researchcore}{$\\bullet$}] PROPOSAL - Research proposals and dissertation work
    \\item[\\textcolor{researchexp}{$\\bullet$}] LASER - Laser alignment and experimental work
    \\item[\\textcolor{researchexp}{$\\bullet$}] EXPERIMENTAL - Imaging, surgery, and data collection
    \\item[\\textcolor{researchout}{$\\bullet$}] PUBLICATION - Manuscripts and presentations
    \\item[\\textcolor{administrative}{$\\bullet$}] ADMINISTRATIVE - Forms, applications, and reviews
    \\item[\\textcolor{accountability}{$\\bullet$}] ACCOUNTABILITY - Meetings and responsibilities
    \\item[\\textcolor{service}{$\\bullet$}] SERVICE - SPIE chapter and other service activities
\\end{itemize}

\\subsection{Task Information}
\\begin{itemize}[leftmargin=2cm]
    \\item[\\textbf{Dependencies}] Tasks that must be completed before this task
    \\item[\\textbf{Description}] Additional details and context for each task
    \\item[\\textbf{Milestones}] Tasks with same start and due date (marked with diamond shapes)
\\end{itemize}
"""


class TaskListGenerator:
    """Generates comprehensive task list views with enhanced formatting."""

    def __init__(self, escaper: LaTeXEscaper = None):
        self.escaper = escaper or LaTeXEscaper()

    def generate_comprehensive_task_list(self, timeline: ProjectTimeline) -> str:
        """Generate a comprehensive task list with enhanced UI/UX formatting."""
        task_list = """
\\section{Complete Task List}
\\vspace{0.5cm}

% Enhanced task list with better spacing and typography
\\begin{enumerate}[leftmargin=1.5cm, itemsep=1em, parsep=0.5em]
"""
        
        for i, task in enumerate(timeline.tasks, 1):
            task_name = self.escaper.escape_latex(task.name)
            task_description = self.escaper.escape_latex(task.notes) if task.notes else ""
            
            # Task header with bold name and category color
            task_list += f"""
    \\item \\textcolor{{{task.category_color}}}{{\\textbf{{\\large {task_name}}}}}
          \\hfill \\textcolor{{black!60}}{{\\small [{task.category}]}}
          
          \\vspace{{0.2em}}
          \\textcolor{{black!70}}{{\\textbf{{Duration:}} {task.start_date.strftime('%B %d, %Y')} -- {task.due_date.strftime('%B %d, %Y')} ({task.duration_days} days)}}
"""
            
            if task.is_milestone:
                task_list += f"          \\textcolor{{orange}}{{\\textbf{{ [MILESTONE]}}}}\\n"
            
            if task.dependencies:
                deps = self.escaper.escape_latex(task.dependencies)
                task_list += f"          \\\\[0.2em]\\textcolor{{black!70}}{{\\textbf{{Dependencies:}} {deps}}}\\n"
            
            if task_description:
                # Format description with proper paragraph breaks
                formatted_description = self._format_comprehensive_description(task_description)
                task_list += f"""
          \\vspace{{0.4em}}
          \\begin{{minipage}}[t]{{0.9\\textwidth}}
          \\textcolor{{black!85}}{{{formatted_description}}}
          \\end{{minipage}}
"""
        
        task_list += "\\end{enumerate}\n"
        return task_list

    def _format_comprehensive_description(self, description: str) -> str:
        """Format task description for comprehensive view with proper paragraphs."""
        if not description:
            return ""
        
        # Split into sentences for better readability
        sentences = description.split('. ')
        if len(sentences) > 1:
            # Add proper sentence endings and create paragraph breaks for long descriptions
            formatted_sentences = []
            for i, sentence in enumerate(sentences):
                if not sentence.endswith('.') and i < len(sentences) - 1:
                    sentence += '.'
                formatted_sentences.append(sentence.strip())
            
            # Group sentences into logical paragraphs (every 2-3 sentences)
            paragraphs = []
            current_paragraph = []
            
            for sentence in formatted_sentences:
                current_paragraph.append(sentence)
                if len(current_paragraph) >= 2:  # Create paragraph break every 2 sentences
                    paragraphs.append(' '.join(current_paragraph))
                    current_paragraph = []
            
            if current_paragraph:
                paragraphs.append(' '.join(current_paragraph))
            
            return '\\\\[0.3em]\n          '.join(paragraphs)
        else:
            return description


class LaTeXGenerator:
    """Main LaTeX generator that coordinates all components."""

    def __init__(self):
        self.escaper = LaTeXEscaper()
        self.document_generator = LaTeXDocumentGenerator(self.escaper)
        self.title_generator = TitlePageGenerator(self.escaper)
        self.calendar_generator = CalendarGenerator(self.escaper)
        self.legend_generator = LegendGenerator(self.escaper)
        self.task_list_generator = TaskListGenerator(self.escaper)

    def generate_complete_document(self, timeline: ProjectTimeline) -> str:
        """Generate the complete LaTeX document."""
        latex_content = self.document_generator.generate_document_header()
        latex_content += self.title_generator.generate_title_page(timeline)
        latex_content += self.task_list_generator.generate_comprehensive_task_list(timeline)
        latex_content += self.calendar_generator.generate_calendar_view(timeline)
        latex_content += self.legend_generator.generate_legend()
        latex_content += self.document_generator.generate_document_footer()

        return latex_content