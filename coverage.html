
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>planner: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">phd-dissertation-planner/cmd/planner/main.go (0.0%)</option>
				
				<option value="file1">phd-dissertation-planner/src/app/cli.go (0.0%)</option>
				
				<option value="file2">phd-dissertation-planner/src/app/generator.go (2.9%)</option>
				
				<option value="file3">phd-dissertation-planner/src/app/template_funcs.go (78.9%)</option>
				
				<option value="file4">phd-dissertation-planner/src/calendar/calendar.go (0.0%)</option>
				
				<option value="file5">phd-dissertation-planner/src/calendar/cell_builder.go (0.0%)</option>
				
				<option value="file6">phd-dissertation-planner/src/calendar/task_stacker.go (78.5%)</option>
				
				<option value="file7">phd-dissertation-planner/src/core/color_utils.go (0.0%)</option>
				
				<option value="file8">phd-dissertation-planner/src/core/config.go (12.0%)</option>
				
				<option value="file9">phd-dissertation-planner/src/core/defaults.go (63.6%)</option>
				
				<option value="file10">phd-dissertation-planner/src/core/errors.go (94.0%)</option>
				
				<option value="file11">phd-dissertation-planner/src/core/logger.go (95.5%)</option>
				
				<option value="file12">phd-dissertation-planner/src/core/reader.go (67.8%)</option>
				
				<option value="file13">phd-dissertation-planner/src/core/task.go (91.7%)</option>
				
				<option value="file14">phd-dissertation-planner/src/shared/templates/rendering.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        "phd-dissertation-planner/src/app"
)

func main() <span class="cov0" title="0">{
        app := app.New()
        if err := app.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Fatal error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "os"

        "phd-dissertation-planner/src/core"

        "github.com/urfave/cli/v2"
)

const (
        fConfig       = "config"
        pConfig       = "preview"
        fOutDir       = "outdir"
        fTestCoverage = "test-coverage"
)

func New() *cli.App <span class="cov0" title="0">{
        // Initialize the composer map
        core.ComposerMap["monthly"] = Monthly

        return &amp;cli.App{
                Name: "plannergen",

                Writer:    os.Stdout,
                ErrWriter: os.Stderr,

                Flags: []cli.Flag{
                        &amp;cli.PathFlag{Name: fConfig, Required: false, Value: "src/core/base.yaml", Usage: "config file(s), comma-separated"},
                        &amp;cli.BoolFlag{Name: pConfig, Required: false, Usage: "render only one page per unique module"},
                        &amp;cli.PathFlag{Name: fOutDir, Required: false, Value: "", Usage: "output directory for generated files (overrides config)"},
                        &amp;cli.BoolFlag{Name: "test-coverage", Required: false, Usage: "run tests with coverage analysis"},
                        &amp;cli.BoolFlag{Name: "validate", Required: false, Usage: "validate CSV file without generating PDF"},
                        &amp;cli.StringFlag{Name: "preset", Required: false, Usage: "Configuration preset: academic, compact, presentation", EnvVars: []string{"PLANNER_PRESET"}},
                },

                Action: action,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package app provides the CLI application interface and document generation.
//
// This package contains:
//   - CLI application setup and command handling
//   - Template loading and rendering
//   - Template helper functions
//   - Document generation orchestration
//
// The package is the main entry point for the planner generation process:
//
// CLI Application:
//
//        New() creates the CLI application with flags for configuration,
//        output directory, and preview mode.
//
// Template System:
//
//        Templates are loaded from embedded files or filesystem (for development).
//        TemplateFuncs() provides custom template functions (dict, incr, dec, is).
//
// Generation Pipeline:
//  1. Load configuration
//  2. Setup output directory
//  3. Generate root document
//  4. Generate individual pages
//
// Example usage:
//
//        // Create and run the application
//        app := app.New()
//        err := app.Run([]string{
//            "plannergen",
//            "--config", "base.yaml",
//            "--outdir", "generated",
//        })
//
// Template functions available in templates:
//   - dict: Create maps from key-value pairs
//   - incr: Increment integers
//   - dec: Decrement integers
//   - is: Check truthiness
//
// Environment variables:
//   - DEV_TEMPLATES: Use filesystem templates instead of embedded
//   - PLANNER_SILENT: Suppress log output
//   - PLANNER_LOG_LEVEL: Set logging level (silent/info/debug)
package app

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "io/fs"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "text/template"
        "time"

        cal "phd-dissertation-planner/src/calendar"
        "phd-dissertation-planner/src/core"
        tmplfs "phd-dissertation-planner/src/shared/templates"

        "github.com/urfave/cli/v2"
)

// Constants for file operations and environment variables
const (
        // File extensions
        texExtension = ".tex"

        // Environment variables
        envDevTemplate = "DEV_TEMPLATES"

        // Directory paths
        templateSubDir = "monthly"
        templatePath   = "src/shared/templates/monthly"
        inputDataDir   = "input_data"

        // Template patterns
        templatePattern = "*.tpl"
        documentTpl     = "document.tpl"

        // Coverage thresholds
        coverageExcellent = 80.0
        coverageWarning   = 60.0

        // CSV file priority levels
        priorityComprehensive = 10
        priorityV51           = 8
        priorityV5            = 6
)

var logger = core.NewDefaultLogger()

// calculatePackageAverage computes the average coverage for a package
func calculatePackageAverage(coverages []float64) float64 <span class="cov0" title="0">{
        if len(coverages) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">sum := 0.0
        for _, cov := range coverages </span><span class="cov0" title="0">{
                sum += cov
        }</span>
        <span class="cov0" title="0">return sum / float64(len(coverages))</span>
}

// getCoverageStatus returns a visual status indicator based on coverage percentage
func getCoverageStatus(coverage float64) string <span class="cov0" title="0">{
        if coverage &gt;= coverageExcellent </span><span class="cov0" title="0">{
                return "‚úÖ"
        }</span> else<span class="cov0" title="0"> if coverage &gt;= coverageWarning </span><span class="cov0" title="0">{
                return "‚ö†Ô∏è "
        }</span>
        <span class="cov0" title="0">return "‚ùå"</span>
}

// printCoverageHeader prints the coverage report header
func printCoverageHeader() <span class="cov0" title="0">{
        fmt.Println("\nüìä Coverage Analysis Report")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
}</span>

// printCoverageRecommendations prints recommendations based on overall coverage
func printCoverageRecommendations(overallCoverage float64) <span class="cov0" title="0">{
        fmt.Println("\nüí° Recommendations:")
        if overallCoverage &lt; coverageWarning </span><span class="cov0" title="0">{
                fmt.Println("  ‚Ä¢ Coverage is low - consider adding more tests")
                fmt.Println("  ‚Ä¢ Focus on testing critical business logic")
        }</span>
        <span class="cov0" title="0">if overallCoverage &gt;= coverageExcellent </span><span class="cov0" title="0">{
                fmt.Println("  ‚Ä¢ Excellent coverage! Keep up the good work")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("  ‚Ä¢ Aim for 80%+ coverage for better reliability")
                fmt.Println("  ‚Ä¢ Add tests for error conditions and edge cases")
        }</span>
}

// calculateCSVPriority determines the priority of a CSV file based on its name
func calculateCSVPriority(filename string) int <span class="cov0" title="0">{
        name := strings.ToLower(filename)

        // Highest priority: comprehensive files
        if strings.Contains(name, "comprehensive") </span><span class="cov0" title="0">{
                return priorityComprehensive
        }</span>

        // Versioned files get priority based on version number
        <span class="cov0" title="0">if strings.Contains(name, "v5.1") </span><span class="cov0" title="0">{
                return priorityV51
        }</span> else<span class="cov0" title="0"> if strings.Contains(name, "v5") </span><span class="cov0" title="0">{
                return priorityV5
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// formatError creates a user-friendly error message with context and suggestions
func formatError(stage, problem string, err error, suggestions ...string) error <span class="cov0" title="0">{
        var msg strings.Builder
        msg.WriteString(fmt.Sprintf("\n‚ùå %s Failed\n\n", stage))
        msg.WriteString(fmt.Sprintf("Problem: %s\n", problem))
        if err != nil </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Details: %v\n", err))
        }</span>

        <span class="cov0" title="0">if len(suggestions) &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString("\nSuggestions:\n")
                for i, suggestion := range suggestions </span><span class="cov0" title="0">{
                        msg.WriteString(fmt.Sprintf("  %d. %s\n", i+1, suggestion))
                }</span>
        }

        <span class="cov0" title="0">msg.WriteString("\nFor more help, see: docs/TROUBLESHOOTING.md\n")
        return fmt.Errorf("%s", msg.String())</span>
}

// action is the main CLI action that orchestrates document generation or test coverage
func action(c *cli.Context) error <span class="cov0" title="0">{
        // Check if test coverage is requested
        if c.Bool(fTestCoverage) </span><span class="cov0" title="0">{
                return runTestCoverage()
        }</span>

        <span class="cov0" title="0">fmt.Println("üöÄ Starting Planner Generation")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Load and prepare configuration
        fmt.Print("üìã Loading configuration... ")
        cfg, pathConfigs, err := loadConfiguration(c)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå")
                return formatError(
                        "Configuration Loading",
                        "Unable to load or parse configuration files",
                        err,
                        "Check that config files exist and are valid YAML",
                        "Verify the --config flag points to the correct file",
                        "Try using a preset: --preset academic",
                )
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ")

        // Setup output directory
        fmt.Print("üìÅ Setting up output directory... ")
        if err := setupOutputDirectory(cfg); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå")
                return formatError(
                        "Output Directory Setup",
                        "Cannot create or access output directory",
                        err,
                        "Check that you have write permissions",
                        "Verify the path is valid and not too long",
                        "Try a different output directory with --outdir flag",
                )
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ")

        // Generate root document
        fmt.Print("üìÑ Generating root document... ")
        if err := generateRootDocument(cfg, pathConfigs); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå")
                return formatError(
                        "Root Document Generation",
                        "Failed to generate main LaTeX document",
                        err,
                        "Check that CSV file exists and is properly formatted",
                        "Verify dates are in YYYY-MM-DD format",
                        "Check for special LaTeX characters in task names (%, $, &amp;, #, _, {, })",
                )
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ")

        // Generate pages
        fmt.Print("üìÖ Generating calendar pages... ")
        preview := c.Bool(pConfig)
        if err := generatePages(cfg, preview); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå")
                return formatError(
                        "Calendar Page Generation",
                        "Failed to generate calendar pages",
                        err,
                        "Check that all task dates are valid",
                        "Verify template files are not corrupted",
                        "Try running with --preview flag for debugging",
                )
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ")

        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Println("‚ú® Generation complete!")
        fmt.Printf("üìÇ Output: %s\n", cfg.OutputDir)

        return nil</span>
}

// runTestCoverage executes tests with coverage analysis and provides formatted results
func runTestCoverage() error <span class="cov0" title="0">{
        fmt.Println("üß™ Running Test Coverage Analysis")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Create coverage output file
        coverageFile := "coverage.out"

        // Run tests with coverage
        cmd := exec.Command("go", "test", "-mod=vendor", "-coverprofile="+coverageFile, "-covermode=count", "./...")
        output, err := cmd.CombinedOutput()

        // Print test results
        if len(output) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Test Results:")
                fmt.Println(string(output))
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Tests failed: %v\n", err)
                return err
        }</span>

        // Check if coverage file was created
        <span class="cov0" title="0">if _, err := os.Stat(coverageFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  No coverage data generated")
                return nil
        }</span>

        // Parse and display coverage report
        <span class="cov0" title="0">if err := analyzeCoverage(coverageFile); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Coverage analysis failed: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// analyzeCoverage parses a Go coverage file and generates a detailed report
// showing per-package coverage statistics and overall project coverage.
// It provides visual indicators and recommendations based on coverage thresholds.
//
// The function reads the coverage file line by line, extracts package information
// from file paths, calculates average coverage per package, and displays a
// comprehensive report with status indicators and improvement recommendations.
//
// Parameters:
//   - coverageFile: path to the coverage.txt file generated by go test
//
// Returns error if the file cannot be read or parsed.
func analyzeCoverage(coverageFile string) error <span class="cov0" title="0">{
        file, err := os.Open(coverageFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open coverage file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)

        // Maps to store coverage data
        packageCoverage := make(map[string][]float64)
        totalStatements := 0
        totalCovered := 0

        // Skip the first line (mode)
        if scanner.Scan() </span>{<span class="cov0" title="0">
                // Skip mode line
        }</span>

        // Parse coverage data
        <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract package name from file path
                <span class="cov0" title="0">filePath := parts[0]
                pathParts := strings.Split(filePath, "/")
                var packageName string
                for i, part := range pathParts </span><span class="cov0" title="0">{
                        if strings.HasSuffix(part, ".go") </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        packageName = pathParts[i-1]
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }

                <span class="cov0" title="0">if packageName == "" </span><span class="cov0" title="0">{
                        packageName = "main"
                }</span>

                // Parse coverage percentage
                <span class="cov0" title="0">coverageStr := strings.TrimSuffix(parts[2], "%")

                coverage, err := strconv.ParseFloat(coverageStr, 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">packageCoverage[packageName] = append(packageCoverage[packageName], coverage)
                totalStatements++
                if coverage &gt; 0 </span><span class="cov0" title="0">{
                        totalCovered++
                }</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading coverage file: %w", err)
        }</span>

        // Calculate and display results
        <span class="cov0" title="0">printCoverageHeader()

        // Package breakdown
        fmt.Println("Package Coverage:")
        for pkg, coverages := range packageCoverage </span><span class="cov0" title="0">{
                if len(coverages) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate average coverage for package
                <span class="cov0" title="0">avgCoverage := calculatePackageAverage(coverages)
                status := getCoverageStatus(avgCoverage)

                fmt.Printf("  %s %-20s %.1f%% (%d files)\n", status, pkg, avgCoverage, len(coverages))</span>
        }

        // Overall statistics
        <span class="cov0" title="0">overallCoverage := 0.0
        if totalStatements &gt; 0 </span><span class="cov0" title="0">{
                overallCoverage = float64(totalCovered) / float64(totalStatements) * 100
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nOverall Coverage: %.1f%%\n", overallCoverage)
        fmt.Printf("Files Analyzed: %d\n", len(packageCoverage))

        // Provide recommendations
        printCoverageRecommendations(overallCoverage)

        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        return nil</span>
}

// loadConfiguration loads and validates the configuration from CLI context
func loadConfiguration(c *cli.Context) (core.Config, []string, error) <span class="cov0" title="0">{
        initialPathConfigs := strings.Split(c.Path(fConfig), ",")

        // Auto-detect CSV and adjust configuration accordingly
        csvPath := os.Getenv("PLANNER_CSV_FILE")
        if csvPath == "" </span><span class="cov0" title="0">{
                autoPath, err := autoDetectCSV()
                if err == nil </span><span class="cov0" title="0">{
                        csvPath = autoPath
                        // Set the CSV path for later use
                        os.Setenv("PLANNER_CSV_FILE", csvPath)
                        fmt.Printf("Auto-detected CSV file: %s\n", csvPath)
                }</span>
        }

        // Auto-detect configuration based on CSV
        <span class="cov0" title="0">pathConfigs := initialPathConfigs
        if csvPath != "" &amp;&amp; len(initialPathConfigs) == 1 &amp;&amp; initialPathConfigs[0] == "src/core/base.yaml" </span><span class="cov0" title="0">{
                autoConfigs, err := autoDetectConfig(csvPath)
                if err == nil &amp;&amp; len(autoConfigs) &gt; 0 </span><span class="cov0" title="0">{
                        pathConfigs = autoConfigs
                        fmt.Printf("Auto-detected configuration files: %v\n", autoConfigs)
                }</span>
        }

        <span class="cov0" title="0">cfg, err := core.NewConfig(pathConfigs...)
        if err != nil </span><span class="cov0" title="0">{
                return core.Config{}, nil, core.NewConfigError(
                        strings.Join(pathConfigs, ","),
                        "",
                        "failed to load configuration",
                        err,
                )
        }</span>

        // Override output directory from CLI flag if provided
        <span class="cov0" title="0">if od := strings.TrimSpace(c.Path(fOutDir)); od != "" </span><span class="cov0" title="0">{
                cfg.OutputDir = od
        }</span>

        <span class="cov0" title="0">return cfg, pathConfigs, nil</span>
}

// setupOutputDirectory ensures the output directory exists and logs its location
func setupOutputDirectory(cfg core.Config) error <span class="cov0" title="0">{
        if err := os.MkdirAll(cfg.OutputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return core.NewFileError(cfg.OutputDir, "create directory", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Output directory: %s", cfg.OutputDir)
        return nil</span>
}

// generateRootDocument creates the main LaTeX document file
func generateRootDocument(cfg core.Config, pathConfigs []string) error <span class="cov0" title="0">{
        wr := &amp;bytes.Buffer{}
        t := NewTpl()

        if err := t.Document(wr, cfg); err != nil </span><span class="cov0" title="0">{
                return core.NewTemplateError(documentTpl, 0, "failed to generate LaTeX document", err)
        }</span>

        <span class="cov0" title="0">logger.Debug("Root document content:\n%s", wr.String())

        outputFile := filepath.Join(cfg.OutputDir, RootFilename(pathConfigs[len(pathConfigs)-1]))
        if err := os.WriteFile(outputFile, wr.Bytes(), 0o600); err != nil </span><span class="cov0" title="0">{
                return core.NewFileError(outputFile, "write", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Generated LaTeX file: %s", outputFile)
        return nil</span>
}

// generatePages creates all page files from the configuration
func generatePages(cfg core.Config, preview bool) error <span class="cov0" title="0">{
        t := NewTpl()

        totalPages := len(cfg.Pages)
        for i, file := range cfg.Pages </span><span class="cov0" title="0">{
                fmt.Printf("\rüìÖ Generating calendar pages... [%d/%d] %s", i+1, totalPages, file.Name)
                if err := generateSinglePage(cfg, file, t, preview); err != nil </span><span class="cov0" title="0">{
                        fmt.Println() // New line before error
                        return err
                }</span>
        }
        <span class="cov0" title="0">fmt.Print("\r") // Clear the progress line

        return nil</span>
}

// generateSinglePage generates a single page file
func generateSinglePage(cfg core.Config, file core.Page, t Tpl, preview bool) error <span class="cov0" title="0">{
        wr := &amp;bytes.Buffer{}

        // Compose all modules for this page
        modules, err := composePageModules(cfg, file, preview)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate module alignment
        <span class="cov0" title="0">if err := validateModuleAlignment(modules, file.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Render modules to buffer
        <span class="cov0" title="0">if err := t.renderModules(wr, modules, file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write page file
        <span class="cov0" title="0">return writePageFile(cfg, file.Name, wr.Bytes())</span>
}

// composePageModules composes all modules for a page by calling composer functions
func composePageModules(cfg core.Config, file core.Page, preview bool) ([]core.Modules, error) <span class="cov0" title="0">{
        var modules = make([]core.Modules, 0, len(file.RenderBlocks))

        for _, block := range file.RenderBlocks </span><span class="cov0" title="0">{
                fn, ok := core.ComposerMap[block.FuncName]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown composer function %q - check configuration", block.FuncName)
                }</span>

                <span class="cov0" title="0">blockModules, err := fn(cfg, block.Tpls)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to compose modules for %q: %w", block.FuncName, err)
                }</span>

                // Only one page per unique module if preview flag is enabled
                <span class="cov0" title="0">if preview </span><span class="cov0" title="0">{
                        blockModules = core.FilterUniqueModules(blockModules)
                }</span>

                <span class="cov0" title="0">modules = append(modules, blockModules)</span>
        }

        <span class="cov0" title="0">if len(modules) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no modules generated for page %q", file.Name)
        }</span>

        <span class="cov0" title="0">return modules, nil</span>
}

// validateModuleAlignment ensures all module arrays have the same length
func validateModuleAlignment(modules []core.Modules, pageName string) error <span class="cov0" title="0">{
        if len(modules) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">expectedLen := len(modules[0])
        for _, mods := range modules </span><span class="cov0" title="0">{
                if len(mods) != expectedLen </span><span class="cov0" title="0">{
                        return fmt.Errorf("module alignment error for page %q: expected %d modules, got %d", pageName, expectedLen, len(mods))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// renderModules renders all modules to the writer using the template
func (t Tpl) renderModules(wr io.Writer, modules []core.Modules, file core.Page) error <span class="cov0" title="0">{
        if len(modules) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">moduleCount := len(modules[0])
        for i := 0; i &lt; moduleCount; i++ </span><span class="cov0" title="0">{
                for j, mod := range modules </span><span class="cov0" title="0">{
                        if err := t.Execute(wr, mod[i].Tpl, mod[i]); err != nil </span><span class="cov0" title="0">{
                                return core.NewTemplateError(
                                        mod[i].Tpl,
                                        0,
                                        fmt.Sprintf("failed to execute template for function %s", file.RenderBlocks[j].FuncName),
                                        err,
                                )
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// writePageFile writes the page content to a file
func writePageFile(cfg core.Config, pageName string, content []byte) error <span class="cov0" title="0">{
        pageFile := filepath.Join(cfg.OutputDir, pageName+texExtension)
        if err := os.WriteFile(pageFile, content, 0o600); err != nil </span><span class="cov0" title="0">{
                return core.NewFileError(pageFile, "write", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Generated page: %s", pageFile)
        return nil</span>
}

func RootFilename(pathconfig string) string <span class="cov0" title="0">{
        filename := filepath.Base(pathconfig)
        return strings.TrimSuffix(filename, filepath.Ext(filename)) + texExtension
}</span>

func escapeLatex(s string) string <span class="cov0" title="0">{
        s = strings.ReplaceAll(s, "&amp;", "\\&amp;")
        s = strings.ReplaceAll(s, "%", "\\%")
        s = strings.ReplaceAll(s, "$", "\\$")
        s = strings.ReplaceAll(s, "#", "\\#")
        s = strings.ReplaceAll(s, "_", "\\_")
        s = strings.ReplaceAll(s, "{", "\\{")
        s = strings.ReplaceAll(s, "}", "\\}")
        return s
}</span>

var tpl = func() *template.Template <span class="cov8" title="1">{
        // Create template with custom functions
        t := template.New("").Funcs(TemplateFuncs())

        // Choose source of templates: embedded by default, filesystem when DEV_TEMPLATES is set
        var (
                err   error
                useFS fs.FS
        )

        if os.Getenv(envDevTemplate) != "" </span><span class="cov0" title="0">{
                // Use on-disk templates for development override
                logger.Debug("Loading templates from filesystem: %s", templatePath)
                useFS = os.DirFS(filepath.Join("src", "shared", "templates", templateSubDir))
        }</span> else<span class="cov8" title="1"> {
                // Use embedded templates from templates.FS
                logger.Debug("Loading embedded templates from: %s", templateSubDir)
                // Narrow to monthly/ subdir
                var sub fs.FS
                sub, err = fs.Sub(tmplfs.FS, templateSubDir)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to access embedded templates directory '%s': %v (check that templates are properly embedded)", templateSubDir, err))</span>
                }
                <span class="cov8" title="1">useFS = sub</span>
        }

        // Parse all *.tpl templates from the selected FS
        <span class="cov8" title="1">t, err = t.ParseFS(useFS, templatePattern)
        if err != nil </span><span class="cov0" title="0">{
                // Provide detailed error message with troubleshooting hints
                if os.Getenv(envDevTemplate) != "" </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to parse templates from filesystem '%s' with pattern '%s': %v\n"+
                                "Check that template files exist and have valid syntax", templatePath, templatePattern, err))</span>
                } else<span class="cov0" title="0"> {
                        panic(fmt.Sprintf("failed to parse embedded templates with pattern '%s': %v\n"+
                                "This may indicate a build issue - ensure templates are embedded correctly", templatePattern, err))</span>
                }
        }

        <span class="cov8" title="1">logger.Debug("Successfully loaded templates with pattern: %s", templatePattern)
        return t</span>
}()

type Tpl struct {
        tpl *template.Template
}

func NewTpl() Tpl <span class="cov0" title="0">{
        return Tpl{
                tpl: tpl,
        }
}</span>

func (t Tpl) Document(wr io.Writer, cfg core.Config) error <span class="cov0" title="0">{
        type pack struct {
                Cfg   core.Config
                Pages []core.Page
        }

        data := pack{Cfg: cfg, Pages: cfg.Pages}
        if err := t.tpl.ExecuteTemplate(wr, documentTpl, data); err != nil </span><span class="cov0" title="0">{
                return core.NewTemplateError(documentTpl, 0, "failed to execute document template", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t Tpl) Execute(wr io.Writer, name string, data interface{}) error <span class="cov0" title="0">{
        // Check if template exists before trying to execute
        if t.tpl.Lookup(name) == nil </span><span class="cov0" title="0">{
                availableTemplates := make([]string, 0)
                for _, tmpl := range t.tpl.Templates() </span><span class="cov0" title="0">{
                        availableTemplates = append(availableTemplates, tmpl.Name())
                }</span>
                <span class="cov0" title="0">return core.NewTemplateError(
                        name,
                        0,
                        fmt.Sprintf("template not found (available: %v)", availableTemplates),
                        nil,
                )</span>
        }

        <span class="cov0" title="0">if err := t.tpl.ExecuteTemplate(wr, name, data); err != nil </span><span class="cov0" title="0">{
                return core.NewTemplateError(name, 0, "failed to execute template", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Monthly(cfg core.Config, tpls []string) (core.Modules, error) <span class="cov0" title="0">{
        // Use legacy monthly generation without layout integration
        return MonthlyLegacy(cfg, tpls)
}</span>

// MonthlyLegacy provides the original monthly generation without layout integration
func MonthlyLegacy(cfg core.Config, tpls []string) (core.Modules, error) <span class="cov0" title="0">{
        // Load tasks from CSV if available
        var tasks []core.Task
        csvPath := cfg.CSVFilePath

        if csvPath != "" </span><span class="cov0" title="0">{
                reader := core.NewReader(csvPath)
                var err error
                tasks, err = reader.ReadTasks()
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue without tasks
                        return nil, fmt.Errorf("error reading tasks: %w", err)
                }</span>
        }

        // If we have months with tasks from CSV, use only those
        <span class="cov0" title="0">if len(cfg.MonthsWithTasks) &gt; 0 </span><span class="cov0" title="0">{
                var modules core.Modules
                if len(tasks) &gt; 0 </span><span class="cov0" title="0">{
                        tocModule := createTableOfContentsModule(cfg, tasks, "toc.tpl")
                        modules = append(modules, tocModule)
                }</span>

                <span class="cov0" title="0">monthModules := make(core.Modules, 0, len(cfg.MonthsWithTasks))

                for _, monthYear := range cfg.MonthsWithTasks </span><span class="cov0" title="0">{
                        year := cal.NewYear(cfg.WeekStart, monthYear.Year, &amp;cfg)

                        // Find the specific month in the year
                        var targetMonth *cal.Month
                        for _, quarter := range year.Quarters </span><span class="cov0" title="0">{
                                for _, month := range quarter.Months </span><span class="cov0" title="0">{
                                        if month.Month == monthYear.Month </span><span class="cov0" title="0">{
                                                targetMonth = month
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if targetMonth != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                        // * Check if targetMonth was found, log warning if not
                        <span class="cov0" title="0">if targetMonth == nil </span><span class="cov0" title="0">{
                                // Log warning but continue processing other months
                                fmt.Printf("Warning: Month %s %d not found in calendar, skipping\n",
                                        monthYear.Month.String(), monthYear.Year)
                                continue</span>
                        }

                        // Assign tasks to days in this month
                        <span class="cov0" title="0">assignTasksToMonth(targetMonth, tasks)

                        monthModules = append(monthModules, core.Module{
                                Cfg: cfg,
                                Tpl: tpls[0],
                                Body: map[string]interface{}{
                                        "Year":         year,
                                        "Quarter":      targetMonth.Quarter,
                                        "Month":        targetMonth,
                                        "MonthRef":     fmt.Sprintf("month-%d-%d", targetMonth.Year.Number, int(targetMonth.Month)),
                                        "Breadcrumb":   targetMonth.Breadcrumb(),
                                        "HeadingMOS":   targetMonth.HeadingMOS(),
                                        "SideQuarters": year.SideQuarters(targetMonth.Quarter.Number),
                                        "SideMonths":   year.SideMonths(targetMonth.Month),
                                        "Extra":        targetMonth.PrevNext().WithTopRightCorner(cfg.ClearTopRightCorner, cfg.Layout.Calendar.TaskKernSpacing),
                                        "Large":        true,
                                        "TableType":    "tabularx",
                                        "Today":        cal.Day{Time: time.Now(), Cfg: &amp;cfg},
                                },
                        })</span>
                }

                // Combine TOC modules with month modules
                <span class="cov0" title="0">modules = append(modules, monthModules...)
                return modules, nil</span>
        } else<span class="cov0" title="0"> {
                // Fallback to original behavior if no CSV data
                years := cfg.GetYears()
                totalMonths := len(years) * 12
                modules := make(core.Modules, 0, totalMonths)

                for _, yearNum := range years </span><span class="cov0" title="0">{
                        year := cal.NewYear(cfg.WeekStart, yearNum, &amp;cfg)

                        for _, quarter := range year.Quarters </span><span class="cov0" title="0">{
                                for _, month := range quarter.Months </span><span class="cov0" title="0">{
                                        modules = append(modules, core.Module{
                                                Cfg: cfg,
                                                Tpl: tpls[0],
                                                Body: map[string]interface{}{
                                                        "Year":         year,
                                                        "Quarter":      quarter,
                                                        "Month":        month,
                                                        "MonthRef":     fmt.Sprintf("month-%d-%d", month.Year.Number, int(month.Month)),
                                                        "Breadcrumb":   month.Breadcrumb(),
                                                        "HeadingMOS":   month.HeadingMOS(),
                                                        "SideQuarters": year.SideQuarters(quarter.Number),
                                                        "SideMonths":   year.SideMonths(month.Month),
                                                        "Extra":        month.PrevNext().WithTopRightCorner(cfg.ClearTopRightCorner, cfg.Layout.Calendar.TaskKernSpacing),
                                                        "Large":        true,
                                                        "TableType":    "tabularx",
                                                        "Today":        cal.Day{Time: time.Now(), Cfg: &amp;cfg},
                                                },
                                        })
                                }</span>
                        }
                }

                <span class="cov0" title="0">return modules, nil</span>
        }
}

// autoDetectCSV searches the input_data directory for CSV files and selects
// the most appropriate one based on a priority system. Priority is determined by:
//   - "comprehensive" in filename (highest priority)
//   - Version numbers (v5.1 &gt; v5)
//   - Most recent modification time (tiebreaker)
//
// The function first checks if the input_data directory exists, then scans for
// CSV files. If multiple files are found, it applies a priority-based selection
// algorithm to choose the most suitable file for processing.
//
// Returns the full path to the selected CSV file or an error if no suitable file is found.
func autoDetectCSV() (string, error) <span class="cov0" title="0">{
        inputDir := inputDataDir

        // Check if input_data directory exists
        if _, err := os.Stat(inputDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("input_data directory not found")
        }</span>

        // Find all CSV files
        <span class="cov0" title="0">files, err := os.ReadDir(inputDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read input_data directory: %w", err)
        }</span>

        <span class="cov0" title="0">var csvFiles []os.DirEntry
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(strings.ToLower(file.Name()), ".csv") </span><span class="cov0" title="0">{
                        csvFiles = append(csvFiles, file)
                }</span>
        }

        <span class="cov0" title="0">if len(csvFiles) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no CSV files found in input_data directory")
        }</span>

        // If only one CSV file, use it
        <span class="cov0" title="0">if len(csvFiles) == 1 </span><span class="cov0" title="0">{
                return filepath.Join(inputDir, csvFiles[0].Name()), nil
        }</span>

        // Multiple CSV files - use priority selection
        // Priority: comprehensive &gt; numbered versions &gt; others
        <span class="cov0" title="0">var bestFile os.DirEntry
        bestPriority := 0

        for _, file := range csvFiles </span><span class="cov0" title="0">{
                priority := calculateCSVPriority(file.Name())

                // Most recent modification time as tiebreaker
                if priority &gt; bestPriority ||
                        (priority == bestPriority &amp;&amp; bestFile == nil) </span><span class="cov0" title="0">{
                        bestPriority = priority
                        bestFile = file
                }</span> else<span class="cov0" title="0"> if priority == bestPriority &amp;&amp; bestFile != nil </span><span class="cov0" title="0">{
                        // Compare modification times
                        currentInfo, err1 := file.Info()
                        bestInfo, err2 := bestFile.Info()
                        if err1 == nil &amp;&amp; err2 == nil &amp;&amp; currentInfo.ModTime().After(bestInfo.ModTime()) </span><span class="cov0" title="0">{
                                bestFile = file
                        }</span>
                }
        }

        <span class="cov0" title="0">if bestFile != nil </span><span class="cov0" title="0">{
                return filepath.Join(inputDir, bestFile.Name()), nil
        }</span>

        // Fallback to first file
        <span class="cov0" title="0">return filepath.Join(inputDir, csvFiles[0].Name()), nil</span>
}

// autoDetectConfig automatically determines appropriate configuration files based on CSV content
func autoDetectConfig(csvPath string) ([]string, error) <span class="cov0" title="0">{
        // Read first few lines to detect version/format
        file, err := os.Open(csvPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open CSV for config detection: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        var lines []string
        for i := 0; i &lt; 5 &amp;&amp; scanner.Scan(); i++ </span><span class="cov0" title="0">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV for config detection: %w", err)
        }</span>

        // Default configuration
        <span class="cov0" title="0">baseConfig := "src/core/base.yaml"

        // Detect CSV version from filename or content
        csvName := strings.ToLower(filepath.Base(csvPath))

        if strings.Contains(csvName, "v5.1") </span><span class="cov0" title="0">{
                // v5.1 format - use monthly calendar config
                return []string{baseConfig, "src/core/monthly_calendar.yaml"}, nil
        }</span> else<span class="cov0" title="0"> if strings.Contains(csvName, "v5") </span><span class="cov0" title="0">{
                // v5 format - use basic calendar config
                return []string{baseConfig, "src/core/calendar.yaml"}, nil
        }</span>

        // Check content for version detection
        <span class="cov0" title="0">if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                header := strings.ToLower(lines[0])
                if strings.Contains(header, "phase") &amp;&amp; strings.Contains(header, "sub-phase") </span><span class="cov0" title="0">{
                        // Has phase and sub-phase columns - v5.1 format
                        return []string{baseConfig, "src/core/monthly_calendar.yaml"}, nil
                }</span>
        }

        // Default to basic configuration
        <span class="cov0" title="0">return []string{baseConfig}, nil</span>
}

// createTableOfContentsModule creates a table of contents module with links to all tasks
func createTableOfContentsModule(cfg core.Config, tasks []core.Task, templateName string) core.Module <span class="cov0" title="0">{
        // Group tasks by phase
        phaseTasks := make(map[string][]core.Task)
        for _, task := range tasks </span><span class="cov0" title="0">{
                task.Name = escapeLatex(task.Name)
                phaseTasks[task.Phase] = append(phaseTasks[task.Phase], task)
        }</span>

        // Sort tasks within each phase
        <span class="cov0" title="0">for _, tasksInPhase := range phaseTasks </span><span class="cov0" title="0">{
                sort.Slice(tasksInPhase, func(i, j int) bool </span><span class="cov0" title="0">{
                        return tasksInPhase[i].StartDate.Before(tasksInPhase[j].StartDate)
                }</span>)
        }

        // Overall stats
        <span class="cov0" title="0">totalTasks := len(tasks)
        milestoneCount := 0
        completedCount := 0
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.IsMilestone </span><span class="cov0" title="0">{
                        milestoneCount++
                }</span>
                <span class="cov0" title="0">if strings.ToLower(task.Status) == "completed" </span><span class="cov0" title="0">{
                        completedCount++
                }</span>
        }

        // Phase stats
        <span class="cov0" title="0">phaseStats := make(map[string]map[string]int)
        for phase, tasksInPhase := range phaseTasks </span><span class="cov0" title="0">{
                stats := make(map[string]int)
                stats["total"] = len(tasksInPhase)
                completed := 0
                milestones := 0
                for _, task := range tasksInPhase </span><span class="cov0" title="0">{
                        if strings.ToLower(task.Status) == "completed" </span><span class="cov0" title="0">{
                                completed++
                        }</span>
                        <span class="cov0" title="0">if task.IsMilestone </span><span class="cov0" title="0">{
                                milestones++
                        }</span>
                }
                <span class="cov0" title="0">stats["completed"] = completed
                stats["milestones"] = milestones
                if stats["total"] &gt; 0 </span><span class="cov0" title="0">{
                        stats["progress"] = int(float64(completed) / float64(stats["total"]) * 100)
                }</span> else<span class="cov0" title="0"> {
                        stats["progress"] = 0
                }</span>
                <span class="cov0" title="0">phaseStats[phase] = stats</span>
        }

        // Extract unique phase names from the CSV data
        <span class="cov0" title="0">phaseNames := make(map[string]string)
        phases := make([]string, 0)

        // Collect unique phases and their names
        phaseMap := make(map[string]string)
        for phase, tasksInPhase := range phaseTasks </span><span class="cov0" title="0">{
                if len(tasksInPhase) &gt; 0 </span><span class="cov0" title="0">{
                        // Use the SubPhase from the first task as the phase name
                        phaseName := tasksInPhase[0].SubPhase
                        if phaseName != "" </span><span class="cov0" title="0">{
                                phaseMap[phase] = fmt.Sprintf("Phase %s: %s", phase, escapeLatex(phaseName))
                        }</span> else<span class="cov0" title="0"> {
                                phaseMap[phase] = fmt.Sprintf("Phase %s", phase)
                        }</span>
                }
        }

        // Sort phases numerically and create the final maps/slices
        <span class="cov0" title="0">for i := 1; i &lt;= 10; i++ </span><span class="cov0" title="0">{ // Support up to 10 phases
                phaseStr := strconv.Itoa(i)
                if phaseName, exists := phaseMap[phaseStr]; exists </span><span class="cov0" title="0">{
                        phaseNames[phaseStr] = phaseName
                        phases = append(phases, phaseStr)
                }</span>
        }

        <span class="cov0" title="0">return core.Module{
                Cfg: cfg,
                Tpl: templateName,
                Body: map[string]interface{}{
                        "TaskIndex":      phaseTasks,
                        "PhaseOrder":     phases,
                        "PhaseNames":     phaseNames,
                        "TotalTasks":     totalTasks,
                        "MilestoneCount": milestoneCount,
                        "CompletedCount": completedCount,
                        "PhaseStats":     phaseStats,
                },
        }</span>
}

// assignTasksToMonth assigns tasks to the appropriate days in a month
func assignTasksToMonth(month *cal.Month, tasks []core.Task) <span class="cov0" title="0">{
        // Convert data.Task to SpanningTask and apply to month
        var spanningTasks []cal.SpanningTask

        for _, task := range tasks </span><span class="cov0" title="0">{
                // Check if task overlaps with this month
                monthStart := time.Date(month.Year.Number, month.Month, 1, 0, 0, 0, 0, time.Local)
                monthEnd := monthStart.AddDate(0, 1, -1)

                if task.StartDate.Before(monthEnd.AddDate(0, 0, 1)) &amp;&amp; task.EndDate.After(monthStart.AddDate(0, 0, -1)) </span><span class="cov0" title="0">{
                        // Create spanning task directly from common.Task
                        // Rendering rules:
                        // - Start day: show a thin colored bar + a single concise text label.
                        // - Middle/end days: show only the bar (no repeated labels).
                        // Therefore, we DO NOT add this task as a regular per-day entry to avoid duplication.
                        spanningTask := cal.CreateSpanningTask(task, task.StartDate, task.EndDate)
                        spanningTasks = append(spanningTasks, spanningTask)
                }</span>
        }

        // Apply spanning tasks to the month for background coloring
        <span class="cov0" title="0">cal.ApplySpanningTasksToMonth(month, spanningTasks)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package app - Template functions provide custom helpers for template rendering.
//
// This module defines all custom template functions available in the template
// rendering engine. Each function is designed to simplify common template operations.
//
// Available functions:
//
// dict: Create maps from key-value pairs
//
//        Usage: {{ template "name" (dict "key1" value1 "key2" value2) }}
//        Useful for passing multiple parameters to templates
//
// incr: Increment an integer by 1
//
//        Usage: {{ incr .Index }}
//        Common for loop counters and pagination
//
// dec: Decrement an integer by 1
//
//        Usage: {{ dec .Index }}
//        Useful for zero-based indexing
//
// is: Check if a value is truthy
//
//        Usage: {{ if is .Value }}...{{ end }}
//        Returns true for non-nil values and explicit true booleans
//        Returns false for nil and explicit false booleans
//
// All functions are thoroughly tested with 100% code coverage.
// See template_funcs_test.go for comprehensive test cases.
//
// Example template usage:
//
//        {{/* Pass multiple values to a sub-template */}}
//        {{ template "header" (dict "title" "My Page" "subtitle" "Details") }}
//
//        {{/* Loop with 1-based indexing */}}
//        {{ range $i, $item := .Items }}
//            {{ incr $i }}. {{ $item.Name }}
//        {{ end }}
//
//        {{/* Conditional rendering */}}
//        {{ if is .OptionalField }}
//            Optional content: {{ .OptionalField }}
//        {{ end }}
package app

import (
        "errors"
        "strings"
        "text/template"

        "phd-dissertation-planner/src/shared/templates"
)

// TemplateFuncs returns a FuncMap with all custom template functions
// These functions are available to all templates during rendering
func TemplateFuncs() template.FuncMap <span class="cov3" title="2">{
        return template.FuncMap{
                "dict":        dictFunc,
                "incr":        incrFunc,
                "dec":         decFunc,
                "is":          isFunc,
                "hypertarget": templates.Hypertarget,
                "lower":       lowerFunc,
                "plus":        plusFunc,
                "mod":         modFunc,
                "replace":     replaceFunc,
        }
}</span>

// dictFunc creates a map from key-value pairs for use in templates
// Usage: {{ template "name" (dict "key1" value1 "key2" value2) }}
func dictFunc(values ...interface{}) (map[string]interface{}, error) <span class="cov6" title="4">{
        if len(values)%2 != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("dict requires an even number of arguments (key-value pairs)")
        }</span>

        <span class="cov5" title="3">dict := make(map[string]interface{}, len(values)/2)
        for i := 0; i &lt; len(values); i += 2 </span><span class="cov5" title="3">{
                key, ok := values[i].(string)
                if !ok </span><span class="cov1" title="1">{
                        return nil, errors.New("dict keys must be strings")
                }</span>
                <span class="cov3" title="2">dict[key] = values[i+1]</span>
        }

        <span class="cov3" title="2">return dict, nil</span>
}

// incrFunc increments an integer by 1
// Usage: {{ incr .Index }}
func incrFunc(i int) int <span class="cov6" title="4">{
        return i + 1
}</span>

// decFunc decrements an integer by 1
// Usage: {{ dec .Index }}
func decFunc(i int) int <span class="cov6" title="4">{
        return i - 1
}</span>

// isFunc checks if a value is truthy
// Returns true for:
// - bool true
// - non-nil values
// Returns false for:
// - bool false
// - nil values
// Usage: {{ if is .Value }}...{{ end }}
func isFunc(i interface{}) bool <span class="cov10" title="11">{
        // Handle explicit boolean values
        if value, ok := i.(bool); ok </span><span class="cov3" title="2">{
                return value
        }</span>

        // All other non-nil values are truthy
        <span class="cov9" title="9">return i != nil</span>
}

// lowerFunc converts a string to lowercase
// Usage: {{ .Value | lower }}
func lowerFunc(s string) string <span class="cov0" title="0">{
        return strings.ToLower(s)
}</span>

// plusFunc adds two integers
// Usage: {{ plus .A .B }}
func plusFunc(a, b int) int <span class="cov0" title="0">{
        return a + b
}</span>

// modFunc returns the modulo of two integers
// Usage: {{ mod .A .B }}
func modFunc(a, b int) int <span class="cov0" title="0">{
        return a % b
}</span>

// replaceFunc replaces all occurrences of a substring
// Usage: {{ .Value | replace "from" "to" }}
func replaceFunc(input, from, to string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(input, from, to)
}</span>

// Additional template helper functions can be added here
// Examples:
// - formatDate: Format time.Time values
// - join: Join string slices
// - default: Provide default values
// - escape: Escape special characters
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package calendar handles calendar layout, task positioning, and LaTeX rendering
// for the PhD dissertation planner system.
//
// Key responsibilities:
// - Calendar grid generation with proper day/week/month structure
// - Task bar positioning and stacking for multi-day spanning tasks
// - Color management for task categories with LaTeX-safe escaping
// - PDF-optimized LaTeX template rendering with proper spacing
package calendar

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "phd-dissertation-planner/src/core"
        "phd-dissertation-planner/src/shared/templates"
)

// ============================================================================
// DATA STRUCTURES
// ============================================================================

// Days is a collection of Day pointers
type Days []*Day

// Day represents a single calendar day with its tasks
type Day struct {
        Time  time.Time
        Tasks []*SpanningTask // All tasks (even 1-day tasks are "spanning")
        Cfg   *core.Config
}

// TaskOverlay represents a spanning task overlay with LaTeX content
type TaskOverlay struct {
        content string // LaTeX content
        cols    int    // Number of columns to span
}

// ============================================================================
// DAY RENDERING
// ============================================================================

// Day renders the day cell for both small and large views
func (d Day) Day(today, large interface{}) string <span class="cov0" title="0">{
        if d.Time.IsZero() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">day := strconv.Itoa(d.Time.Day())

        if larg, _ := large.(bool); larg </span><span class="cov0" title="0">{
                return d.renderLargeDay(day)
        }</span>

        <span class="cov0" title="0">if td, ok := today.(Day); ok </span><span class="cov0" title="0">{
                if d.Time.Equal(td.Time) </span><span class="cov0" title="0">{
                        return templates.EmphCell(day)
                }</span>
        }

        <span class="cov0" title="0">return day</span>
}

// renderLargeDay renders the day cell for large (monthly) view with tasks
func (d Day) renderLargeDay(day string) string <span class="cov0" title="0">{
        leftCell := d.buildDayNumberCell(day)

        // Check for tasks using intelligent stacking
        overlay := d.renderSpanningTaskOverlay()
        if overlay != nil </span><span class="cov0" title="0">{
                // Use spanning mode if any task spans more than 1 column
                isSpanning := overlay.cols &gt; 1
                return d.buildTaskCell(leftCell, overlay.content, isSpanning, overlay.cols)
        }</span>

        // No tasks: just the day number
        <span class="cov0" title="0">return d.buildSimpleDayCell(leftCell)</span>
}

// ref generates a reference string for the day
func (d Day) ref(prefix ...string) string <span class="cov0" title="0">{
        p := ""

        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>

        <span class="cov0" title="0">return p + d.Time.Format(time.RFC3339)</span>
}

// ============================================================================
// LATEX CELL CONSTRUCTION
// ============================================================================

// cellConfig holds configuration values for cell rendering
type cellConfig struct {
        dayNumberWidth   string
        dayContentMargin string
        hyphenPenalty    int
        tolerance        int
        emergencyStretch string
}

// getCellConfig extracts cell configuration from Day config with fallbacks
func (d Day) getCellConfig() cellConfig <span class="cov0" title="0">{
        return cellConfig{
                dayNumberWidth:   d.Cfg.GetDayNumberWidth(),
                dayContentMargin: d.Cfg.GetDayContentMargin(),
                hyphenPenalty:    d.Cfg.GetHyphenPenalty(),
                tolerance:        d.Cfg.GetTolerance(),
                emergencyStretch: d.Cfg.GetEmergencyStretch(),
        }
}</span>

// cellLayout defines the LaTeX layout parameters for a cell
type cellLayout struct {
        width          string
        spacing        string
        contentWrapper string
}

// buildDayNumberCell creates the basic day number cell with minimal padding and hypertarget
// Uses minipage instead of tabular to eliminate auto padding
func (d Day) buildDayNumberCell(day string) string <span class="cov0" title="0">{
        cfg := d.getCellConfig()
        // Create hypertarget for this day to enable hyperlink navigation
        hypertarget := fmt.Sprintf(`\hypertarget{%s}{}`, d.ref())
        return hypertarget + `\begin{minipage}[t]{` + cfg.dayNumberWidth + `}\centering{}` + day + `\end{minipage}`
}</span>

// buildTaskCell creates a cell with either spanning tasks or regular tasks
func (d Day) buildTaskCell(leftCell, content string, isSpanning bool, cols int) string <span class="cov0" title="0">{
        cfg := d.getCellConfig()
        layout := d.determineCellLayout(content, isSpanning, cols, cfg)

        inner := d.buildCellInner(leftCell, layout)
        return d.wrapWithHyperlink(inner)
}</span>

// determineCellLayout determines the appropriate layout based on task type
func (d Day) determineCellLayout(content string, isSpanning bool, cols int, cfg cellConfig) cellLayout <span class="cov0" title="0">{
        if isSpanning </span><span class="cov0" title="0">{
                return d.buildSpanningLayout(content, cols)
        }</span> else<span class="cov0" title="0"> if cols &gt; 0 </span><span class="cov0" title="0">{
                return d.buildVerticalStackLayout(content)
        }</span>
        <span class="cov0" title="0">return d.buildRegularLayout(content, cfg)</span>
}

// buildSpanningLayout creates layout for spanning tasks using tikzpicture overlay
func (d Day) buildSpanningLayout(content string, cols int) cellLayout <span class="cov0" title="0">{
        width := `\dimexpr ` + strconv.Itoa(cols) + `\linewidth\relax`
        spacing := `\makebox[0pt][l]{` + `\begin{tikzpicture}[overlay]` +
                `\node[anchor=north west, inner sep=0pt] at (0,0) {` + `\begin{minipage}[t]{` + width + `}` + content + `\end{minipage}` + `};` +
                `\end{tikzpicture}` + `}`

        return cellLayout{
                width:          width,
                spacing:        spacing,
                contentWrapper: "", // Don't add content twice for spanning tasks
        }
}</span>

// buildVerticalStackLayout creates layout for vertically stacked tasks
func (d Day) buildVerticalStackLayout(content string) cellLayout <span class="cov0" title="0">{
        return cellLayout{
                width:          `\linewidth`, // Just use the cell width
                spacing:        "",           // No offset
                contentWrapper: content,      // Use content directly
        }
}</span>

// buildRegularLayout creates layout for regular tasks with text flow
func (d Day) buildRegularLayout(content string, cfg cellConfig) cellLayout <span class="cov0" title="0">{
        width := `\dimexpr\linewidth - ` + cfg.dayContentMargin + `\relax`
        spacing := `\hspace*{` + cfg.dayNumberWidth + `}`
        contentWrapper := fmt.Sprintf(`{\sloppy\hyphenpenalty=%d\tolerance=%d\emergencystretch=%s\footnotesize\raggedright `,
                cfg.hyphenPenalty, cfg.tolerance, cfg.emergencyStretch) + content + `}`

        return cellLayout{
                width:          width,
                spacing:        spacing,
                contentWrapper: contentWrapper,
        }
}</span>

// buildCellInner constructs the inner content of a cell
func (d Day) buildCellInner(leftCell string, layout cellLayout) string <span class="cov0" title="0">{
        return `{\begingroup` +
                `\makebox[0pt][l]{` + leftCell + `}` +
                layout.spacing +
                `\begin{minipage}[t]{` + layout.width + `}` +
                layout.contentWrapper +
                `\end{minipage}` +
                `\endgroup}`
}</span>

// wrapWithHyperlink wraps content with a hyperlink to the day's reference
func (d Day) wrapWithHyperlink(inner string) string <span class="cov0" title="0">{
        return `\hyperlink{` + d.ref() + `}{` + inner + `}`
}</span>

// buildSimpleDayCell creates a simple day cell without tasks
func (d Day) buildSimpleDayCell(leftCell string) string <span class="cov0" title="0">{
        inner := `{\begingroup\makebox[0pt][l]{` + leftCell + `}\endgroup}`
        return d.wrapWithHyperlink(inner)
}</span>

// ============================================================================
// TASK RENDERING - SPANNING TASKS
// ============================================================================

// renderSpanningTaskOverlay creates a task overlay with proper vertical stacking
// Uses track-based positioning to prevent visual overlap of multi-day tasks
func (d Day) renderSpanningTaskOverlay() *TaskOverlay <span class="cov0" title="0">{
        dayDate := d.getDayDate()
        activeTasks, maxCols := d.findActiveTasks(dayDate)

        if len(activeTasks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Assign tracks to ALL active tasks (including continuing ones)
        // This ensures consistent track assignments across days
        <span class="cov0" title="0">trackAssignments := d.assignTaskTracks(activeTasks)

        // Build rendering lists: tasks that START today vs. tasks that CONTINUE today
        var startingTasks []*SpanningTask
        var continuingTasks []*SpanningTask

        // Categorize active tasks
        for _, task := range activeTasks </span><span class="cov0" title="0">{
                start := d.getTaskStartDate(task)
                if dayDate.Equal(start) </span><span class="cov0" title="0">{
                        // This task starts today
                        startingTasks = append(startingTasks, task)
                }</span> else<span class="cov0" title="0"> {
                        // This task is continuing from a previous day
                        continuingTasks = append(continuingTasks, task)
                }</span>
        }

        // Combine all tasks that need rendering (starting tasks get full rendering, continuing tasks get continuation indicators)
        <span class="cov0" title="0">var allTasksToRender = make([]*SpanningTask, 0, len(activeTasks))
        renderingTypes := make(map[*SpanningTask]string) // "start" or "continue"

        // Add starting tasks
        for _, task := range startingTasks </span><span class="cov0" title="0">{
                allTasksToRender = append(allTasksToRender, task)
                renderingTypes[task] = "start"
        }</span>

        // Add continuing tasks that should show visual indicators
        <span class="cov0" title="0">for _, task := range continuingTasks </span><span class="cov0" title="0">{
                allTasksToRender = append(allTasksToRender, task)
                renderingTypes[task] = "continue"
        }</span>

        // Sort tasks by their assigned track (lowest track first, renders at bottom)
        <span class="cov0" title="0">sortedTasks := make([]*SpanningTask, len(allTasksToRender))
        copy(sortedTasks, allTasksToRender)
        for i := 0; i &lt; len(sortedTasks)-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(sortedTasks)-i-1; j++ </span><span class="cov0" title="0">{
                        track1 := trackAssignments[sortedTasks[j].ID]
                        track2 := trackAssignments[sortedTasks[j+1].ID]
                        if track1 &gt; track2 </span><span class="cov0" title="0">{
                                sortedTasks[j], sortedTasks[j+1] = sortedTasks[j+1], sortedTasks[j]
                        }</span>
                }
        }

        // Render task pills with vertical offsets based on track
        <span class="cov0" title="0">var pillContents = make([]string, 0, len(sortedTasks))

        for i, task := range sortedTasks </span><span class="cov0" title="0">{
                renderType := renderingTypes[task]

                // Skip rendering text for continuing tasks - just show the colored bar
                if renderType == "continue" </span><span class="cov0" title="0">{
                        // Don't render anything for continuing tasks
                        // The visual bar will span automatically via the cols parameter
                        continue</span>
                }

                // Render starting task (original logic)
                <span class="cov0" title="0">taskName := d.escapeLatexSpecialChars(task.Name)
                if d.isMilestoneSpanningTask(task) </span><span class="cov0" title="0">{
                        taskName = "‚òÖ " + taskName
                }</span>

                <span class="cov0" title="0">objective := ""
                if task.Description != "" </span><span class="cov0" title="0">{
                        objective = d.escapeLatexSpecialChars(task.Description)
                }</span>

                <span class="cov0" title="0">taskColor := core.HexToRGB(task.Color)
                if taskColor == "" </span><span class="cov0" title="0">{
                        taskColor = core.Defaults.DefaultTaskColor
                }</span>

                // Add spacing between stacked tasks (except for the first task)
                <span class="cov0" title="0">var spacing string
                if i &gt; 0 </span><span class="cov0" title="0">{
                        spacing = `\vspace{1mm}` // Add 1mm spacing between stacked tasks
                }</span>

                // Choose appropriate macro based on whether task is a milestone
                <span class="cov0" title="0">var macroName string
                if task.IsMilestone </span><span class="cov0" title="0">{
                        macroName = `\MilestoneTaskOverlayBox`
                }</span> else<span class="cov0" title="0"> {
                        macroName = `\TaskOverlayBox`
                }</span>

                // Use appropriate macro - LaTeX will stack naturally with spacing
                <span class="cov0" title="0">pillContent := spacing + fmt.Sprintf(`%s{%s}{%s}{%s}`,
                        macroName,
                        taskColor,
                        taskName,
                        objective)
                pillContents = append(pillContents, pillContent)</span>
        }

        // Join the pills - they will stack naturally bottom-to-top
        <span class="cov0" title="0">content := strings.Join(pillContents, "")

        return &amp;TaskOverlay{
                content: content,
                cols:    maxCols,
        }</span>
}

// ============================================================================
// HELPER FUNCTIONS - DATE AND TASK UTILITIES
// ============================================================================

// getDayDate returns the day date normalized to UTC midnight
func (d Day) getDayDate() time.Time <span class="cov0" title="0">{
        return time.Date(d.Time.Year(), d.Time.Month(), d.Time.Day(), 0, 0, 0, 0, time.UTC)
}</span>

// getTaskStartDate returns the task start date normalized to UTC midnight
func (d Day) getTaskStartDate(task *SpanningTask) time.Time <span class="cov0" title="0">{
        return time.Date(task.StartDate.Year(), task.StartDate.Month(), task.StartDate.Day(), 0, 0, 0, 0, time.UTC)
}</span>

// getTaskEndDate returns the task end date normalized to UTC midnight
func (d Day) getTaskEndDate(task *SpanningTask) time.Time <span class="cov0" title="0">{
        return time.Date(task.EndDate.Year(), task.EndDate.Month(), task.EndDate.Day(), 0, 0, 0, 0, time.UTC)
}</span>

// isTaskActiveOnDay checks if a task is active on the given day
func (d Day) isTaskActiveOnDay(dayDate, start, end time.Time) bool <span class="cov0" title="0">{
        return !dayDate.Before(start) &amp;&amp; !dayDate.After(end)
}</span>

// calculateTaskSpanColumns calculates how many columns a task should span
func (d Day) calculateTaskSpanColumns(dayDate, end time.Time) int <span class="cov0" title="0">{
        idxMonFirst := (int(dayDate.Weekday()) + 6) % 7 // Monday=0
        remainInRow := 7 - idxMonFirst
        totalRemain := int(end.Sub(dayDate).Hours()/24) + 1
        if totalRemain &lt; 1 </span><span class="cov0" title="0">{
                totalRemain = 1
        }</span>
        <span class="cov0" title="0">overlayCols := totalRemain
        if overlayCols &gt; remainInRow </span><span class="cov0" title="0">{
                overlayCols = remainInRow
        }</span>
        <span class="cov0" title="0">return overlayCols</span>
}

// findActiveTasks finds ALL tasks that should reserve vertical space on this day
// This includes:
// 1. Tasks that START on this day (will show task bar)
// 2. Tasks that STARTED EARLIER but are still active (need space but don't show bar)
// This ensures proper vertical stacking to prevent visual overlap
func (d Day) findActiveTasks(dayDate time.Time) ([]*SpanningTask, int) <span class="cov0" title="0">{
        var activeTasks []*SpanningTask
        var maxCols int
        seen := make(map[*SpanningTask]bool)

        for _, task := range d.Tasks </span><span class="cov0" title="0">{
                start := d.getTaskStartDate(task)
                end := d.getTaskEndDate(task)

                // Include task if it's active on this day (either starting or continuing)
                if d.isTaskActiveOnDay(dayDate, start, end) &amp;&amp; !seen[task] </span><span class="cov0" title="0">{
                        activeTasks = append(activeTasks, task)
                        seen[task] = true

                        // Calculate columns differently based on whether task starts today
                        var cols int
                        if dayDate.Equal(start) </span><span class="cov0" title="0">{
                                // Task starts today: span from today to end (or end of week)
                                cols = d.calculateTaskSpanColumns(dayDate, end)
                        }</span> else<span class="cov0" title="0"> {
                                // Task started earlier: calculate remaining span
                                cols = d.calculateRemainingSpanColumns(dayDate, end)
                        }</span>

                        <span class="cov0" title="0">if cols &gt; maxCols </span><span class="cov0" title="0">{
                                maxCols = cols
                        }</span>
                }
        }

        // Sort tasks by start date (earlier tasks appear first/on bottom)
        <span class="cov0" title="0">activeTasks = d.sortTasksByStartDate(activeTasks)

        return activeTasks, maxCols</span>
}

// assignTaskTracks assigns vertical tracks to tasks to prevent visual overlap
// Returns a map of task ID to track number (0-based, 0 is bottom)
func (d Day) assignTaskTracks(tasks []*SpanningTask) map[string]int <span class="cov0" title="0">{
        trackAssignments := make(map[string]int)

        // For each task, find the lowest available track
        for _, task := range tasks </span><span class="cov0" title="0">{
                track := d.findLowestAvailableTrackForTask(task, trackAssignments)
                trackAssignments[task.ID] = track
        }</span>

        <span class="cov0" title="0">return trackAssignments</span>
}

// findLowestAvailableTrackForTask finds the lowest track that doesn't conflict with already-assigned tasks
func (d Day) findLowestAvailableTrackForTask(task *SpanningTask, existing map[string]int) int <span class="cov0" title="0">{
        taskStart := d.getTaskStartDate(task)
        taskEnd := d.getTaskEndDate(task)

        // Check each track starting from 0
        for track := 0; track &lt; 100; track++ </span><span class="cov0" title="0">{
                occupied := false

                // Check if any existing task on this track overlaps with our task
                for otherTaskID, otherTrack := range existing </span><span class="cov0" title="0">{
                        if otherTrack != track </span><span class="cov0" title="0">{
                                continue</span> // Different track, no conflict
                        }

                        // Find the other task
                        <span class="cov0" title="0">for _, otherTask := range d.Tasks </span><span class="cov0" title="0">{
                                if otherTask.ID == otherTaskID </span><span class="cov0" title="0">{
                                        otherStart := d.getTaskStartDate(otherTask)
                                        otherEnd := d.getTaskEndDate(otherTask)

                                        // Check if date ranges overlap
                                        if d.dateRangesOverlap(taskStart, taskEnd, otherStart, otherEnd) </span><span class="cov0" title="0">{
                                                occupied = true
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">if occupied </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !occupied </span><span class="cov0" title="0">{
                        return track
                }</span>
        }

        <span class="cov0" title="0">return 0</span> // Fallback
}

// dateRangesOverlap checks if two date ranges overlap
func (d Day) dateRangesOverlap(start1, end1, start2, end2 time.Time) bool <span class="cov0" title="0">{
        // Two ranges overlap if: start1 &lt;= end2 AND start2 &lt;= end1
        return !start1.After(end2) &amp;&amp; !start2.After(end1)
}</span>

// calculateRemainingSpanColumns calculates how many columns a continuing task spans
// from the current day to its end (or end of week, whichever is sooner)
func (d Day) calculateRemainingSpanColumns(dayDate, end time.Time) int <span class="cov0" title="0">{
        idxMonFirst := (int(dayDate.Weekday()) + 6) % 7 // Monday=0
        remainInRow := 7 - idxMonFirst
        daysLeft := int(end.Sub(dayDate).Hours()/24) + 1

        if daysLeft &lt; 1 </span><span class="cov0" title="0">{
                return 1 // At least show on current day
        }</span>
        <span class="cov0" title="0">if daysLeft &gt; remainInRow </span><span class="cov0" title="0">{
                return remainInRow
        }</span>
        <span class="cov0" title="0">return daysLeft</span>
}

// sortTasksByStartDate sorts tasks by their start date (earliest first)
func (d Day) sortTasksByStartDate(tasks []*SpanningTask) []*SpanningTask <span class="cov0" title="0">{
        sorted := make([]*SpanningTask, len(tasks))
        copy(sorted, tasks)

        // Sort by start date (earliest first)
        for i := 0; i &lt; len(sorted)-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(sorted)-i-1; j++ </span><span class="cov0" title="0">{
                        if sorted[j].StartDate.After(sorted[j+1].StartDate) </span><span class="cov0" title="0">{
                                sorted[j], sorted[j+1] = sorted[j+1], sorted[j]
                        }</span>
                }
        }

        <span class="cov0" title="0">return sorted</span>
}

// isMilestoneSpanningTask checks if a task is a milestone
func (d Day) isMilestoneSpanningTask(task *SpanningTask) bool <span class="cov0" title="0">{
        return strings.HasPrefix(strings.ToUpper(strings.TrimSpace(task.Description)), "MILESTONE:")
}</span>

// ============================================================================
// HELPER FUNCTIONS - LATEX UTILITIES
// ============================================================================

// escapeLatexSpecialChars replaces special LaTeX characters with their escaped versions
func escapeLatexSpecialChars(text string) string <span class="cov0" title="0">{
        // Replace special LaTeX characters with their escaped versions
        text = strings.ReplaceAll(text, "\\", "\\textbackslash{}")
        text = strings.ReplaceAll(text, "{", "\\{")
        text = strings.ReplaceAll(text, "}", "\\}")
        text = strings.ReplaceAll(text, "$", "\\$")
        text = strings.ReplaceAll(text, "&amp;", "\\&amp;")
        text = strings.ReplaceAll(text, "%", "\\%")
        text = strings.ReplaceAll(text, "#", "\\#")
        text = strings.ReplaceAll(text, "^", "\\textasciicircum{}")
        text = strings.ReplaceAll(text, "_", "\\_")
        text = strings.ReplaceAll(text, "~", "\\textasciitilde{}")

        return text
}</span>

// escapeLatexSpecialChars escapes special LaTeX characters in text
func (d Day) escapeLatexSpecialChars(text string) string <span class="cov0" title="0">{
        // Replace special LaTeX characters with their escaped versions
        text = strings.ReplaceAll(text, "\\", "\\textbackslash{}")
        text = strings.ReplaceAll(text, "{", "\\{")
        text = strings.ReplaceAll(text, "}", "\\}")
        text = strings.ReplaceAll(text, "$", "\\$")
        text = strings.ReplaceAll(text, "&amp;", "\\&amp;")
        text = strings.ReplaceAll(text, "%", "\\%")
        text = strings.ReplaceAll(text, "#", "\\#")
        text = strings.ReplaceAll(text, "^", "\\textasciicircum{}")
        text = strings.ReplaceAll(text, "_", "\\_")
        text = strings.ReplaceAll(text, "~", "\\textasciitilde{}")
        return text
}</span>

// ============================================================================
// WEEK STRUCTURES AND METHODS
// ============================================================================

type Weeks []*Week
type Week struct {
        Days [7]Day

        Weekday  time.Weekday
        Year     *Year
        Months   Months
        Quarters Quarters
}

func NewWeeksForMonth(wd time.Weekday, year *Year, qrtr *Quarter, month *Month, cfg *core.Config) Weeks <span class="cov0" title="0">{
        ptr := time.Date(year.Number, month.Month, 1, 0, 0, 0, 0, time.Local)
        weekday := ptr.Weekday()
        shift := (7 + weekday - wd) % 7

        week := &amp;Week{Weekday: wd, Year: year, Months: Months{month}, Quarters: Quarters{qrtr}}

        for i := shift; i &lt; 7; i++ </span><span class="cov0" title="0">{
                week.Days[i] = Day{Time: ptr, Tasks: nil, Cfg: cfg}
                ptr = ptr.AddDate(0, 0, 1)
        }</span>

        <span class="cov0" title="0">weeks := Weeks{}
        weeks = append(weeks, week)

        for ptr.Month() == month.Month </span><span class="cov0" title="0">{
                week = &amp;Week{Weekday: weekday, Year: year, Months: Months{month}, Quarters: Quarters{qrtr}}

                for i := 0; i &lt; 7; i++ </span><span class="cov0" title="0">{
                        if ptr.Month() != month.Month </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">week.Days[i] = Day{Time: ptr, Tasks: nil, Cfg: cfg}
                        ptr = ptr.AddDate(0, 0, 1)</span>
                }

                <span class="cov0" title="0">weeks = append(weeks, week)</span>
        }

        <span class="cov0" title="0">return weeks</span>
}

func (w *Week) HasDays() bool <span class="cov0" title="0">{
        for _, d := range w.Days </span><span class="cov0" title="0">{
                if !d.Time.IsZero() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (w *Week) WeekNumber(large interface{}) string <span class="cov0" title="0">{
        wn := w.weekNumber()
        larg, _ := large.(bool)

        itoa := strconv.Itoa(wn)
        ref := w.ref()
        if !larg </span><span class="cov0" title="0">{
                return templates.Link(ref, itoa)
        }</span>

        <span class="cov0" title="0">text := `\rotatebox[origin=tr]{90}{\makebox[\myLenMonthlyCellHeight][c]{Week ` + itoa + `}}`

        return templates.Link(ref, text)</span>
}

func (w *Week) weekNumber() int <span class="cov0" title="0">{
        // Calculate sequential week number for the entire year (1-based)
        // Find the first non-zero day in the week
        var firstDay time.Time
        for _, day := range w.Days </span><span class="cov0" title="0">{
                if !day.Time.IsZero() </span><span class="cov0" title="0">{
                        firstDay = day.Time
                        break</span>
                }
        }

        <span class="cov0" title="0">if firstDay.IsZero() </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Find the first day of the year
        <span class="cov0" title="0">firstOfYear := time.Date(firstDay.Year(), 1, 1, 0, 0, 0, 0, firstDay.Location())

        // Calculate how many days from the start of the year to the first day of this week
        daysFromStart := int(firstDay.Sub(firstOfYear).Hours() / 24)

        // Calculate the week number (1-based, starting from the first week of the year)
        weekNum := (daysFromStart / 7) + 1

        // Ensure we don't go below 1
        if weekNum &lt; 1 </span><span class="cov0" title="0">{
                weekNum = 1
        }</span>

        <span class="cov0" title="0">return weekNum</span>
}

func (w Week) ref(prefix ...string) string <span class="cov0" title="0">{
        p := ""
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>
        <span class="cov0" title="0">return p + "week-" + strconv.Itoa(w.Year.Number) + "-" + strconv.Itoa(w.weekNumber())</span>
}

func NewWeeksForYear(wd time.Weekday, year *Year, cfg *core.Config) Weeks <span class="cov0" title="0">{
        var weeks Weeks
        ptr := time.Date(year.Number, 1, 1, 0, 0, 0, 0, time.Local)
        weekday := ptr.Weekday()
        _ = (7 + weekday - wd) % 7

        for i := 0; i &lt; 53; i++ </span><span class="cov0" title="0">{
                week := &amp;Week{Weekday: wd, Year: year}
                for j := 0; j &lt; 7; j++ </span><span class="cov0" title="0">{
                        week.Days[j] = Day{Time: ptr, Tasks: nil, Cfg: cfg}
                        ptr = ptr.AddDate(0, 0, 1)
                }</span>
                <span class="cov0" title="0">weeks = append(weeks, week)</span>
        }

        <span class="cov0" title="0">return weeks</span>
}

// ============================================================================
// MONTH STRUCTURES AND METHODS
// ============================================================================

type Months []*Month

func (m Months) Months() []time.Month <span class="cov0" title="0">{
        if len(m) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">out := make([]time.Month, 0, len(m))

        for _, month := range m </span><span class="cov0" title="0">{
                out = append(out, month.Month)
        }</span>

        <span class="cov0" title="0">return out</span>
}

type Month struct {
        Year    *Year
        Quarter *Quarter
        Month   time.Month
        Weekday time.Weekday
        Weeks   Weeks
        Cfg     *core.Config // * Reference to core configuration
}

func NewMonth(wd time.Weekday, year *Year, qrtr *Quarter, month time.Month, cfg *core.Config) *Month <span class="cov0" title="0">{
        m := &amp;Month{
                Year:    year,
                Quarter: qrtr,
                Month:   month,
                Weekday: wd,
                Cfg:     cfg,
        }

        m.Weeks = NewWeeksForMonth(wd, year, qrtr, m, cfg)

        return m
}</span>

func (m Month) Breadcrumb() string <span class="cov0" title="0">{
        return templates.Items{
                templates.NewIntItem(m.Year.Number),
                templates.NewTextItem("Q" + strconv.Itoa(m.Quarter.Number)),
                templates.NewMonthItem(m.Month),
        }.Table(true)
}</span>

func (m Month) MonthLink() string <span class="cov0" title="0">{
        return templates.Link(m.ref(), m.Month.String())
}</span>

func (m Month) ref(prefix ...string) string <span class="cov0" title="0">{
        p := ""
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>
        <span class="cov0" title="0">return p + "month-" + strconv.Itoa(m.Year.Number) + "-" + strconv.Itoa(int(m.Month))</span>
}

// HeadingMOS creates a heading for the month-overview-single view
func (m Month) HeadingMOS(prefix ...string) string <span class="cov0" title="0">{
        leaf := ""
        if len(prefix) &gt; 1 </span><span class="cov0" title="0">{
                leaf = prefix[1]
        }</span>
        <span class="cov0" title="0">p := ""
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>
        <span class="cov0" title="0">monthStr := m.Month.String()
        if len(leaf) &gt; 0 </span><span class="cov0" title="0">{
                monthStr = templates.Link(m.ref(p), monthStr)
        }</span>

        // Use config helper for header angle size offset
        <span class="cov0" title="0">headerAngleOffset := m.Cfg.GetHeaderAngleSizeOffset()
        anglesize := `\dimexpr\myLenHeaderResizeBox-` + headerAngleOffset
        var ll, rl string
        var r1, r2 []string
        if m.PrevExists() </span><span class="cov0" title="0">{
                ll = "l"
                leftNavBox := templates.ResizeBoxW(anglesize, `$\langle$`)
                r1 = append(r1, templates.Multirow(2, templates.Hyperlink(m.Prev().ref(p), leftNavBox)))
                r2 = append(r2, "")
        }</span>
        <span class="cov0" title="0">r1 = append(r1, templates.Multirow(2, templates.ResizeBoxW(`\myLenHeaderResizeBox`, monthStr)))
        r2 = append(r2, "")
        r1 = append(r1, templates.Bold(m.Month.String()))
        r2 = append(r2, strconv.Itoa(m.Year.Number))
        if m.NextExists() </span><span class="cov0" title="0">{
                rl = "l"
                rightNavBox := templates.ResizeBoxW(anglesize, `$\rangle$`)
                r1 = append(r1, templates.Multirow(2, templates.Hyperlink(m.Next().ref(p), rightNavBox)))
                r2 = append(r2, "")
        }</span>
        <span class="cov0" title="0">contents := strings.Join(r1, ` &amp; `) + `\\` + "\n" + strings.Join(r2, ` &amp; `)
        return templates.Hypertarget(p+m.ref(), "") + templates.Tabular("@{}"+ll+"l|l"+rl, contents)</span>
}

// PrevNext creates navigation items for previous and next months
func (m Month) PrevNext(prefix ...string) templates.Items <span class="cov0" title="0">{
        p := ""
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>
        <span class="cov0" title="0">items := templates.Items{}

        if m.PrevExists() </span><span class="cov0" title="0">{
                prev := m.Prev()
                items = append(items, templates.NewTextItem(prev.Month.String()).RefText(p+prev.ref()))
        }</span>

        <span class="cov0" title="0">if m.NextExists() </span><span class="cov0" title="0">{
                next := m.Next()
                items = append(items, templates.NewTextItem(next.Month.String()).RefText(p+next.ref()))
        }</span>

        <span class="cov0" title="0">return items</span>
}

// Prev returns the previous month
func (m Month) Prev() Month <span class="cov0" title="0">{
        if m.Month == time.January </span><span class="cov0" title="0">{
                return Month{Year: m.Year, Quarter: m.Quarter, Month: time.December}
        }</span>
        <span class="cov0" title="0">return Month{Year: m.Year, Quarter: m.Quarter, Month: m.Month - 1}</span>
}

// Next returns the next month
func (m Month) Next() Month <span class="cov0" title="0">{
        if m.Month == time.December </span><span class="cov0" title="0">{
                return Month{Year: m.Year, Quarter: m.Quarter, Month: time.January}
        }</span>
        <span class="cov0" title="0">return Month{Year: m.Year, Quarter: m.Quarter, Month: m.Month + 1}</span>
}

// PrevExists checks if the previous month exists
func (m Month) PrevExists() bool <span class="cov0" title="0">{
        return m.Month &gt; time.January
}</span>

// NextExists checks if the next month exists
func (m Month) NextExists() bool <span class="cov0" title="0">{
        return m.Month &lt; time.December
}</span>

func (m *Month) DefineTable(typ interface{}, large interface{}) string <span class="cov0" title="0">{
        full, _ := large.(bool)

        typStr, ok := typ.(string)
        if !ok || typStr == "tabularx" </span><span class="cov0" title="0">{
                weekAlign := "Y|"
                days := "Y"
                if full </span><span class="cov0" title="0">{
                        // Large mode: use zero-width paragraph column to force minimal width
                        weekAlign = `|l!{\vrule width \myLenLineThicknessThick}`
                        days = `@{}X@{}|`
                }</span>

                <span class="cov0" title="0">return `\begin{tabularx}{\linewidth}{` + weekAlign + `*{7}{` + days + `}}`</span>
        }

        <span class="cov0" title="0">return `\begin{tabular}[t]{c|*{7}{c}}`</span>
}

func (m *Month) EndTable(typ interface{}) string <span class="cov0" title="0">{
        typStr, ok := typ.(string)
        if !ok || typStr == "tabularx" </span><span class="cov0" title="0">{
                return `\end{tabularx}`
        }</span>

        <span class="cov0" title="0">return `\end{tabular}`</span>
}

func (m *Month) MaybeName(large interface{}) string <span class="cov0" title="0">{
        larg, _ := large.(bool)

        if larg </span><span class="cov0" title="0">{ // likely on a monthly page; no need to print it again
                return ""
        }</span>

        <span class="cov0" title="0">return `\multicolumn{8}{c}{` + templates.Link(m.Month.String(), m.Month.String()) + `} \\ \hline`</span>
}

func (m *Month) WeekHeader(large interface{}) string <span class="cov0" title="0">{
        full, _ := large.(bool)

        names := make([]string, 0, 8)

        if full </span><span class="cov0" title="0">{
                names = append(names, "")
        }</span> else<span class="cov0" title="0"> {
                names = append(names, "W")
        }</span>

        <span class="cov0" title="0">for i := time.Sunday; i &lt; 7; i++ </span><span class="cov0" title="0">{
                name := ((m.Weekday + i) % 7).String()
                if full </span><span class="cov0" title="0">{
                        // Add vertical padding with \rule for equal top/bottom spacing
                        name = `\hfil{}\rule{0pt}{2.5ex}\rule[-1ex]{0pt}{0pt}` + name
                }</span> else<span class="cov0" title="0"> {
                        name = name[:1]
                }</span>

                <span class="cov0" title="0">names = append(names, name)</span>
        }

        <span class="cov0" title="0">return strings.Join(names, " &amp; ")</span>
}

func (m *Month) GetTaskColors() map[string]string <span class="cov0" title="0">{
        colorMap := make(map[string]string)

        // Only add colors for task categories that are actually present in this month
        for _, week := range m.Weeks </span><span class="cov0" title="0">{
                for _, day := range week.Days </span><span class="cov0" title="0">{
                        for _, task := range day.Tasks </span><span class="cov0" title="0">{
                                if task.Category != "" </span><span class="cov0" title="0">{
                                        color := core.GenerateCategoryColor(task.Category)
                                        if color != "" </span><span class="cov0" title="0">{
                                                // Convert to RGB for LaTeX compatibility
                                                // Escape LaTeX special characters in category name
                                                escapedCategory := escapeLatexSpecialChars(task.Category)
                                                colorMap[core.HexToRGB(color)] = escapedCategory
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return colorMap</span>
}

// PhaseGroup represents a phase with its sub-phases and colors for the legend
type PhaseGroup struct {
        PhaseNumber string
        PhaseName   string
        SubPhases   []SubPhaseLegendItem
}

// SubPhaseLegendItem represents a sub-phase entry in the legend
type SubPhaseLegendItem struct {
        Name  string
        Color string // RGB format for LaTeX
}

// GetTaskColorsByPhase returns tasks grouped by phase for a structured legend
func (m *Month) GetTaskColorsByPhase() []PhaseGroup <span class="cov0" title="0">{
        // Map to track unique phase -&gt; subphase -&gt; color
        phaseMap := make(map[string]map[string]string)
        phaseNames := make(map[string]string) // phase number -&gt; full phase description

        // Collect all unique phase/subphase combinations in this month
        for _, week := range m.Weeks </span><span class="cov0" title="0">{
                for _, day := range week.Days </span><span class="cov0" title="0">{
                        for _, task := range day.Tasks </span><span class="cov0" title="0">{
                                if task.Phase != "" &amp;&amp; task.SubPhase != "" </span><span class="cov0" title="0">{
                                        // Initialize phase map if needed
                                        if phaseMap[task.Phase] == nil </span><span class="cov0" title="0">{
                                                phaseMap[task.Phase] = make(map[string]string)
                                        }</span>

                                        // Get color for this subphase (category)
                                        <span class="cov0" title="0">color := core.GenerateCategoryColor(task.SubPhase)
                                        if color != "" </span><span class="cov0" title="0">{
                                                phaseMap[task.Phase][task.SubPhase] = core.HexToRGB(color)
                                        }</span>

                                        // Store phase name (use first non-empty one)
                                        <span class="cov0" title="0">if phaseNames[task.Phase] == "" &amp;&amp; task.SubPhase != "" </span><span class="cov0" title="0">{
                                                phaseNames[task.Phase] = task.SubPhase
                                        }</span>
                                }
                        }
                }
        }

        // Convert to sorted structure
        <span class="cov0" title="0">var phases []PhaseGroup
        phaseOrder := []string{"1", "2", "3", "4"} // Typical phase numbering

        for _, phaseNum := range phaseOrder </span><span class="cov0" title="0">{
                if subPhases, exists := phaseMap[phaseNum]; exists </span><span class="cov0" title="0">{
                        phase := PhaseGroup{
                                PhaseNumber: phaseNum,
                                PhaseName:   getPhaseDescription(phaseNum),
                        }

                        // Add each subphase
                        for subPhaseName, color := range subPhases </span><span class="cov0" title="0">{
                                phase.SubPhases = append(phase.SubPhases, SubPhaseLegendItem{
                                        Name:  escapeLatexSpecialChars(subPhaseName),
                                        Color: color,
                                })
                        }</span>

                        <span class="cov0" title="0">phases = append(phases, phase)</span>
                }
        }

        <span class="cov0" title="0">return phases</span>
}

// getPhaseDescription returns a human-readable phase description
func getPhaseDescription(phaseNum string) string <span class="cov0" title="0">{
        descriptions := map[string]string{
                "1": "Phase 1: Proposal \\&amp; Setup",
                "2": "Phase 2: Research \\&amp; Data Collection",
                "3": "Phase 3: Publications",
                "4": "Phase 4: Dissertation",
        }

        if desc, exists := descriptions[phaseNum]; exists </span><span class="cov0" title="0">{
                return desc
        }</span>
        <span class="cov0" title="0">return "Phase " + phaseNum</span>
}

// ============================================================================
// YEAR AND QUARTER STRUCTURES
// ============================================================================

type Years []*Year

type Year struct {
        Number   int
        Quarters Quarters
        Weeks    Weeks
}

func NewYear(wd time.Weekday, year int, cfg *core.Config) *Year <span class="cov0" title="0">{
        out := &amp;Year{Number: year}
        out.Weeks = NewWeeksForYear(wd, out, cfg)
        for q := 1; q &lt;= 4; q++ </span><span class="cov0" title="0">{
                out.Quarters = append(out.Quarters, NewQuarter(wd, out, q, cfg))
        }</span>
        <span class="cov0" title="0">return out</span>
}

func (y Year) Breadcrumb() string <span class="cov0" title="0">{
        return templates.Items{
                templates.NewIntItem(y.Number),
        }.Table(true)
}</span>

func (y Year) YearLink() string <span class="cov0" title="0">{
        return templates.Link(y.ref(), strconv.Itoa(y.Number))
}</span>

func (y Year) ref(prefix ...string) string <span class="cov0" title="0">{
        p := ""
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>
        <span class="cov0" title="0">return p + "year-" + strconv.Itoa(y.Number)</span>
}

// SideQuarters returns the quarters for the year
func (y Year) SideQuarters(quarterNumber ...int) Quarters <span class="cov0" title="0">{
        return y.Quarters
}</span>

// SideMonths returns all months for the year
func (y Year) SideMonths(month ...time.Month) Months <span class="cov0" title="0">{
        var months Months
        for _, quarter := range y.Quarters </span><span class="cov0" title="0">{
                months = append(months, quarter.Months...)
        }</span>
        <span class="cov0" title="0">return months</span>
}

type Quarters []*Quarter

type Quarter struct {
        Number int
        Year   *Year
        Months Months
}

func NewQuarter(wd time.Weekday, year *Year, quarter int, cfg *core.Config) *Quarter <span class="cov0" title="0">{
        out := &amp;Quarter{Number: quarter, Year: year}
        for m := 1; m &lt;= 3; m++ </span><span class="cov0" title="0">{
                month := time.Month((quarter-1)*3 + m)
                out.Months = append(out.Months, NewMonth(wd, year, out, month, cfg))
        }</span>
        <span class="cov0" title="0">return out</span>
}

func (q Quarter) Breadcrumb() string <span class="cov0" title="0">{
        return templates.Items{
                templates.NewIntItem(q.Year.Number),
                templates.NewTextItem("Q" + strconv.Itoa(q.Number)),
        }.Table(true)
}</span>

func (q Quarter) QuarterLink() string <span class="cov0" title="0">{
        return templates.Link(q.ref(), "Q"+strconv.Itoa(q.Number))
}</span>

func (q Quarter) ref(prefix ...string) string <span class="cov0" title="0">{
        p := ""
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                p = prefix[0]
        }</span>
        <span class="cov0" title="0">return p + "quarter-" + strconv.Itoa(q.Year.Number) + "-" + strconv.Itoa(q.Number)</span>
}

// ============================================================================
// SPANNING TASK DATA STRUCTURES AND UTILITIES
// ============================================================================

// SpanningTask represents a task that spans multiple days
type SpanningTask struct {
        ID          string
        Name        string
        Description string
        Phase       string // Added: Phase number
        SubPhase    string // Added: Sub-Phase description
        Category    string
        StartDate   time.Time
        EndDate     time.Time
        Color       string
        Progress    int    // Progress percentage (0-100)
        Status      string // Task status
        Assignee    string // Task assignee
        IsMilestone bool   // Whether this is a milestone task
}

// CreateSpanningTask creates a new spanning task from basic task data
func CreateSpanningTask(task core.Task, startDate, endDate time.Time) SpanningTask <span class="cov0" title="0">{
        // * Use Sub-Phase as category for better granularity
        color := core.GenerateCategoryColor(task.Category)

        return SpanningTask{
                ID:          task.ID,
                Name:        task.Name,
                Description: task.Description,
                Phase:       task.Phase,    // * Added: Include Phase
                SubPhase:    task.SubPhase, // * Added: Include SubPhase
                Category:    task.Category, // * Fixed: Use Category field
                StartDate:   startDate,
                EndDate:     endDate,
                Color:       color,
                Progress:    0,                // Default progress
                Status:      task.Status,      // * Fixed: Use actual Status field
                Assignee:    task.Assignee,    // * Fixed: Use actual Assignee field
                IsMilestone: task.IsMilestone, // * Added: Pass milestone status
        }
}</span>

// ApplySpanningTasksToMonth applies spanning tasks to a month
func ApplySpanningTasksToMonth(month *Month, tasks []SpanningTask) <span class="cov0" title="0">{
        // Apply spanning tasks to the appropriate days in the month
        for taskIndex, task := range tasks </span><span class="cov0" title="0">{
                // Find all days in the month that this task spans
                current := task.StartDate
                for !current.After(task.EndDate) </span><span class="cov0" title="0">{
                        // Check if this day is in the current month
                        if current.Month() == month.Month &amp;&amp; current.Year() == month.Year.Number </span><span class="cov0" title="0">{
                                // Find the day in the month and set the spanning task
                                for _, week := range month.Weeks </span><span class="cov0" title="0">{
                                        for i := range week.Days </span><span class="cov0" title="0">{
                                                if week.Days[i].Time.Day() == current.Day() &amp;&amp;
                                                        week.Days[i].Time.Month() == current.Month() &amp;&amp;
                                                        week.Days[i].Time.Year() == current.Year() </span><span class="cov0" title="0">{
                                                        // Create a copy of the task to avoid pointer issues
                                                        taskCopy := tasks[taskIndex]
                                                        // Add the spanning task to this day
                                                        week.Days[i].Tasks = append(week.Days[i].Tasks, &amp;taskCopy)
                                                        break</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">current = current.AddDate(0, 0, 1)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package calendar provides cell building functionality for the PhD dissertation planner.
//
// This module handles:
// - Day cell construction with proper spacing and alignment
// - Task cell building with different layouts
// - LaTeX cell formatting and minipage management
package calendar

import (
        "fmt"
        "strconv"

        "phd-dissertation-planner/src/core"
)

// CellBuilder handles construction of calendar cells
type CellBuilder struct {
        cfg *core.Config
}

// NewCellBuilder creates a new cell builder with the given configuration
func NewCellBuilder(cfg *core.Config) *CellBuilder <span class="cov0" title="0">{
        return &amp;CellBuilder{cfg: cfg}
}</span>

// BuildDayNumberCell creates the basic day number cell with minimal padding and hypertarget
func (cb *CellBuilder) BuildDayNumberCell(day string, ref ...string) string <span class="cov0" title="0">{
        dayNumberWidth := "6mm" // Default width
        dayNumberCell := fmt.Sprintf(`\begin{minipage}[t]{%s}\centering{}%s\end{minipage}`, dayNumberWidth, day)

        // Add hypertarget if reference is provided
        if len(ref) &gt; 0 &amp;&amp; ref[0] != "" </span><span class="cov0" title="0">{
                hypertarget := fmt.Sprintf(`\hypertarget{%s}{}`, ref[0])
                return hypertarget + dayNumberCell
        }</span>

        <span class="cov0" title="0">return dayNumberCell</span>
}

// BuildSimpleDayCell creates a simple day cell with just the day number
func (cb *CellBuilder) BuildSimpleDayCell(leftCell string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\hyperlink{%s}{%s}`, "", leftCell)
}</span>

// BuildTaskCell constructs a task cell with proper spacing and alignment
func (cb *CellBuilder) BuildTaskCell(leftCell, content string, isSpanning bool, cols int) string <span class="cov0" title="0">{
        dayNumberWidth := "6mm"   // Default width
        dayContentMargin := "1mm" // Default margin

        var width, spacing, contentWrapper string

        // Get typography settings
        hyphenPenalty := 10000    // Default value
        tolerance := 1000         // Default value
        emergencyStretch := "2em" // Default value

        if cb.cfg.Layout.LaTeX.Typography.HyphenPenalty != 0 </span><span class="cov0" title="0">{
                hyphenPenalty = cb.cfg.Layout.LaTeX.Typography.HyphenPenalty
        }</span>
        <span class="cov0" title="0">if cb.cfg.Layout.LaTeX.Typography.Tolerance != 0 </span><span class="cov0" title="0">{
                tolerance = cb.cfg.Layout.LaTeX.Typography.Tolerance
        }</span>
        <span class="cov0" title="0">if cb.cfg.Layout.LaTeX.Typography.SloppyEmergencyStretch != "" </span><span class="cov0" title="0">{
                emergencyStretch = cb.cfg.Layout.LaTeX.Typography.SloppyEmergencyStretch
        }</span>

        <span class="cov0" title="0">if isSpanning </span><span class="cov0" title="0">{
                // Spanning task: use tikzpicture overlay with calculated width (z-dimension stacking)
                width = `\dimexpr ` + strconv.Itoa(cols) + `\linewidth\relax`
                spacing = `\makebox[0pt][l]{` + `\begin{tikzpicture}[overlay]` +
                        `\node[anchor=north west, inner sep=0pt] at (0,0) {` + `\begin{minipage}[t]{` + width + `}` + content + `\end{minipage}` + `};` +
                        `\end{tikzpicture}` + `}`
                contentWrapper = "" // Don't add content twice for spanning tasks
        }</span> else<span class="cov0" title="0"> if cols &gt; 0 </span><span class="cov0" title="0">{
                // Spanning task but rendered as regular content (vertical stacking)
                spacing = ""             // No offset - start at the beginning of the cell
                contentWrapper = content // Use the content directly without additional wrapping
        }</span> else<span class="cov0" title="0"> {
                // Regular task: use full available width with fixed height container
                width = `\dimexpr\linewidth - ` + dayContentMargin + `\relax` // Leave space for day number + margins
                spacing = `\hspace*{` + dayNumberWidth + `}`                  // Spacing to align with day number cell width
                // Wrap in fixed-height minipage to prevent row expansion
                contentWrapper = `\begin{minipage}[t][\myLenMonthlyCellHeight][t]{` + width + `}` +
                        fmt.Sprintf(`{\sloppy\hyphenpenalty=%d\tolerance=%d\emergencystretch=%s\footnotesize\raggedright `,
                                hyphenPenalty, tolerance, emergencyStretch) + content + `}` +
                        `\end{minipage}`
        }</span>

        <span class="cov0" title="0">inner := `{\begingroup` +
                `\makebox[0pt][l]{` + leftCell + `}` +
                spacing +
                contentWrapper +
                `\endgroup}`

        // Wrap entire cell in hyperlink to the day's reference (restores link without visual borders via hypersetup)
        return fmt.Sprintf(`\hyperlink{%s}{%s}`, "", inner)</span>
}

// BuildWeekHeaderCell creates a week header cell
func (cb *CellBuilder) BuildWeekHeaderCell(weekNum int) string <span class="cov0" title="0">{
        weekHeaderHeight := "\\myLenMonthlyCellHeight" // Default height

        return fmt.Sprintf(`\hyperlink{week-%d}{\rotatebox[origin=tr]{90}{\makebox[%s][c]{Week %d}}}`,
                weekNum, weekHeaderHeight, weekNum)
}</span>

// BuildMonthHeaderCell creates a month header cell
func (cb *CellBuilder) BuildMonthHeaderCell(monthName string, monthNum int) string <span class="cov0" title="0">{
        monthHeaderHeight := "\\myLenMonthlyCellHeight" // Default height

        return fmt.Sprintf(`\hyperlink{month-%d}{\rotatebox[origin=tr]{90}{\makebox[%s][c]{%s}}}`,
                monthNum, monthHeaderHeight, monthName)
}</span>

// BuildEmptyCell creates an empty cell
func (cb *CellBuilder) BuildEmptyCell() string <span class="cov0" title="0">{
        return `&amp;`
}</span>

// BuildCellSeparator creates a cell separator
func (cb *CellBuilder) BuildCellSeparator() string <span class="cov0" title="0">{
        return `\\`
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package calendar provides task stacking and overlap detection for multi-day tasks.
//
// This module handles:
// - Detection of overlapping tasks across multiple days
// - Intelligent stacking of tasks to prevent visual overlap
// - Assignment of vertical layers (tracks) to tasks
// - Optimization of track usage for compact visualization
package calendar

import (
        "sort"
        "time"
)

// TaskStack represents a vertical track assignment for tasks
type TaskStack struct {
        Track    int           // Vertical position (0 = top, 1 = second, etc.)
        Task     *SpanningTask // The task in this track
        StartCol int           // Starting column in the week (0-6, Monday-Sunday)
        EndCol   int           // Ending column in the week (0-6, Monday-Sunday)
}

// DayTaskStack represents all tasks that should be displayed on a specific day
type DayTaskStack struct {
        Date   time.Time
        Stacks []TaskStack // All tasks visible on this day, organized by track
}

// TaskStacker manages task overlap detection and track assignment
type TaskStacker struct {
        tasks        []*SpanningTask
        dayStacks    map[string]*DayTaskStack // Key: date string (YYYY-MM-DD)
        maxTracks    int                      // Maximum number of tracks needed for any day
        weekStartDay time.Weekday             // First day of week (Monday = 1)
}

// NewTaskStacker creates a new task stacker
func NewTaskStacker(tasks []*SpanningTask, weekStartDay time.Weekday) *TaskStacker <span class="cov3" title="5">{
        return &amp;TaskStacker{
                tasks:        tasks,
                dayStacks:    make(map[string]*DayTaskStack),
                weekStartDay: weekStartDay,
        }
}</span>

// ComputeStacks analyzes all tasks and computes optimal track assignments
// This is the main algorithm that prevents visual overlaps
func (ts *TaskStacker) ComputeStacks() <span class="cov3" title="5">{
        // Sort tasks by start date, then by duration (longer tasks first)
        sortedTasks := ts.sortTasksByPriority()

        // For each task, find the lowest available track across all its days
        for _, task := range sortedTasks </span><span class="cov5" title="10">{
                track := ts.findLowestAvailableTrack(task)
                ts.assignTaskToTrack(task, track)
        }</span>
}

// sortTasksByPriority sorts tasks for optimal stacking
// Priority: earlier start date, then longer duration
func (ts *TaskStacker) sortTasksByPriority() []*SpanningTask <span class="cov3" title="5">{
        sorted := make([]*SpanningTask, len(ts.tasks))
        copy(sorted, ts.tasks)

        sort.Slice(sorted, func(i, j int) bool </span><span class="cov3" title="5">{
                // First, sort by start date
                if !sorted[i].StartDate.Equal(sorted[j].StartDate) </span><span class="cov3" title="5">{
                        return sorted[i].StartDate.Before(sorted[j].StartDate)
                }</span>

                // If start dates are equal, longer tasks first
                <span class="cov0" title="0">durationI := sorted[i].EndDate.Sub(sorted[i].StartDate)
                durationJ := sorted[j].EndDate.Sub(sorted[j].StartDate)
                return durationI &gt; durationJ</span>
        })

        <span class="cov3" title="5">return sorted</span>
}

// findLowestAvailableTrack finds the lowest track number that's free for all days of the task
func (ts *TaskStacker) findLowestAvailableTrack(task *SpanningTask) int <span class="cov5" title="10">{
        // Get all dates this task spans
        dates := ts.getDateRange(task.StartDate, task.EndDate)

        // Check each track starting from 0
        for track := 0; track &lt; 100; track++ </span><span class="cov6" title="15">{ // Reasonable upper limit
                available := true

                // Check if this track is available for ALL days the task spans
                for _, date := range dates </span><span class="cov8" title="63">{
                        if ts.isTrackOccupied(date, track) </span><span class="cov3" title="5">{
                                available = false
                                break</span>
                        }
                }

                <span class="cov6" title="15">if available </span><span class="cov5" title="10">{
                        return track
                }</span>
        }

        // Fallback: return a high track number
        <span class="cov0" title="0">return 99</span>
}

// isTrackOccupied checks if a track is occupied on a specific date
func (ts *TaskStacker) isTrackOccupied(date time.Time, track int) bool <span class="cov8" title="63">{
        dateKey := ts.dateKey(date)
        dayStack, exists := ts.dayStacks[dateKey]

        if !exists </span><span class="cov7" title="36">{
                return false
        }</span>

        // Check if any task in this track overlaps this date
        <span class="cov7" title="27">for _, stack := range dayStack.Stacks </span><span class="cov7" title="34">{
                if stack.Track == track </span><span class="cov3" title="5">{
                        return true
                }</span>
        }

        <span class="cov6" title="22">return false</span>
}

// assignTaskToTrack assigns a task to a specific track for all its days
func (ts *TaskStacker) assignTaskToTrack(task *SpanningTask, track int) <span class="cov5" title="10">{
        dates := ts.getDateRange(task.StartDate, task.EndDate)

        for _, date := range dates </span><span class="cov8" title="58">{
                dateKey := ts.dateKey(date)

                // Get or create day stack
                dayStack, exists := ts.dayStacks[dateKey]
                if !exists </span><span class="cov7" title="36">{
                        dayStack = &amp;DayTaskStack{
                                Date:   date,
                                Stacks: []TaskStack{},
                        }
                        ts.dayStacks[dateKey] = dayStack
                }</span>

                // Calculate column positions for this specific week
                <span class="cov8" title="58">startCol, endCol := ts.calculateWeekColumns(task, date)

                // Add task to this day's stack
                dayStack.Stacks = append(dayStack.Stacks, TaskStack{
                        Track:    track,
                        Task:     task,
                        StartCol: startCol,
                        EndCol:   endCol,
                })

                // Update max tracks
                if track+1 &gt; ts.maxTracks </span><span class="cov5" title="9">{
                        ts.maxTracks = track + 1
                }</span>
        }
}

// calculateWeekColumns calculates which columns a task occupies in the week containing the given date
func (ts *TaskStacker) calculateWeekColumns(task *SpanningTask, date time.Time) (startCol, endCol int) <span class="cov8" title="58">{
        // Get the week boundaries for this date
        weekStart := ts.getWeekStart(date)
        weekEnd := weekStart.AddDate(0, 0, 6)

        // Clamp task dates to week boundaries
        taskStart := task.StartDate
        taskEnd := task.EndDate

        if taskStart.Before(weekStart) </span><span class="cov7" title="28">{
                taskStart = weekStart
        }</span>
        <span class="cov8" title="58">if taskEnd.After(weekEnd) </span><span class="cov6" title="23">{
                taskEnd = weekEnd
        }</span>

        // Calculate column indices (0-6 for Mon-Sun if weekStartDay is Monday)
        <span class="cov8" title="58">startCol = int((taskStart.Weekday() - ts.weekStartDay + 7) % 7)
        endCol = int((taskEnd.Weekday() - ts.weekStartDay + 7) % 7)

        return startCol, endCol</span>
}

// getWeekStart returns the first day of the week containing the given date
func (ts *TaskStacker) getWeekStart(date time.Time) time.Time <span class="cov8" title="58">{
        // Normalize to start of day
        date = time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())

        // Calculate days back to week start
        daysBack := int((date.Weekday() - ts.weekStartDay + 7) % 7)
        weekStart := date.AddDate(0, 0, -daysBack)

        return weekStart
}</span>

// GetStacksForDay returns all task stacks for a specific day, sorted by track
func (ts *TaskStacker) GetStacksForDay(date time.Time) []TaskStack <span class="cov4" title="7">{
        dateKey := ts.dateKey(date)
        dayStack, exists := ts.dayStacks[dateKey]

        if !exists </span><span class="cov0" title="0">{
                return []TaskStack{}
        }</span>

        // Sort by track number
        <span class="cov4" title="7">stacks := make([]TaskStack, len(dayStack.Stacks))
        copy(stacks, dayStack.Stacks)

        sort.Slice(stacks, func(i, j int) bool </span><span class="cov3" title="4">{
                return stacks[i].Track &lt; stacks[j].Track
        }</span>)

        <span class="cov4" title="7">return stacks</span>
}

// GetTasksStartingOnDay returns tasks that START on the given day, with their track assignments
func (ts *TaskStacker) GetTasksStartingOnDay(date time.Time) []TaskStack <span class="cov2" title="2">{
        dateKey := ts.dateKey(date)
        dayStack, exists := ts.dayStacks[dateKey]

        if !exists </span><span class="cov0" title="0">{
                return []TaskStack{}
        }</span>

        // Filter to only tasks that start on this day
        <span class="cov2" title="2">var startingTasks []TaskStack
        normalizedDate := ts.normalizeDate(date)

        for _, stack := range dayStack.Stacks </span><span class="cov3" title="3">{
                taskStartDate := ts.normalizeDate(stack.Task.StartDate)
                if taskStartDate.Equal(normalizedDate) </span><span class="cov2" title="2">{
                        startingTasks = append(startingTasks, stack)
                }</span>
        }

        // Sort by track number
        <span class="cov2" title="2">sort.Slice(startingTasks, func(i, j int) bool </span><span class="cov0" title="0">{
                return startingTasks[i].Track &lt; startingTasks[j].Track
        }</span>)

        <span class="cov2" title="2">return startingTasks</span>
}

// GetMaxTracks returns the maximum number of tracks needed
func (ts *TaskStacker) GetMaxTracks() int <span class="cov2" title="2">{
        return ts.maxTracks
}</span>

// Helper methods

// dateKey creates a unique key for a date (YYYY-MM-DD format)
func (ts *TaskStacker) dateKey(date time.Time) string <span class="cov10" title="130">{
        return date.Format("2006-01-02")
}</span>

// normalizeDate normalizes a date to midnight UTC
func (ts *TaskStacker) normalizeDate(date time.Time) time.Time <span class="cov8" title="45">{
        return time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, time.UTC)
}</span>

// getDateRange returns all dates between start and end (inclusive)
func (ts *TaskStacker) getDateRange(start, end time.Time) []time.Time <span class="cov6" title="20">{
        start = ts.normalizeDate(start)
        end = ts.normalizeDate(end)

        var dates []time.Time
        current := start

        for !current.After(end) </span><span class="cov9" title="116">{
                dates = append(dates, current)
                current = current.AddDate(0, 0, 1)
        }</span>

        <span class="cov6" title="20">return dates</span>
}

// TaskStackRenderer provides rendering information for stacked tasks
type TaskStackRenderer struct {
        stacker *TaskStacker
}

// NewTaskStackRenderer creates a new renderer for stacked tasks
func NewTaskStackRenderer(tasks []*SpanningTask, weekStartDay time.Weekday) *TaskStackRenderer <span class="cov0" title="0">{
        stacker := NewTaskStacker(tasks, weekStartDay)
        stacker.ComputeStacks()

        return &amp;TaskStackRenderer{
                stacker: stacker,
        }
}</span>

// GetRenderInfoForDay returns rendering information for tasks on a specific day
func (tsr *TaskStackRenderer) GetRenderInfoForDay(date time.Time) *DayRenderInfo <span class="cov0" title="0">{
        stacks := tsr.stacker.GetStacksForDay(date)
        startingTasks := tsr.stacker.GetTasksStartingOnDay(date)

        return &amp;DayRenderInfo{
                Date:               date,
                AllStacks:          stacks,
                StartingTasks:      startingTasks,
                MaxTracks:          tsr.stacker.GetMaxTracks(),
                TasksVisibleOnDay:  len(stacks),
                TasksStartingOnDay: len(startingTasks),
        }
}</span>

// DayRenderInfo contains all information needed to render tasks for a specific day
type DayRenderInfo struct {
        Date               time.Time
        AllStacks          []TaskStack // All tasks visible on this day (including those that started earlier)
        StartingTasks      []TaskStack // Only tasks that START on this day
        MaxTracks          int         // Maximum tracks for proper cell height
        TasksVisibleOnDay  int         // Total number of tasks visible
        TasksStartingOnDay int         // Number of tasks starting on this day
}

// ShouldShowContinuation returns true if this day shows continuation bars for tasks started earlier
func (dri *DayRenderInfo) ShouldShowContinuation() bool <span class="cov0" title="0">{
        return dri.TasksVisibleOnDay &gt; dri.TasksStartingOnDay
}</span>

// GetContinuationTasks returns tasks that are continuing from previous days
func (dri *DayRenderInfo) GetContinuationTasks() []TaskStack <span class="cov0" title="0">{
        if !dri.ShouldShowContinuation() </span><span class="cov0" title="0">{
                return []TaskStack{}
        }</span>

        <span class="cov0" title="0">normalizedDate := time.Date(dri.Date.Year(), dri.Date.Month(), dri.Date.Day(), 0, 0, 0, 0, time.UTC)

        var continuations []TaskStack
        for _, stack := range dri.AllStacks </span><span class="cov0" title="0">{
                taskStartDate := time.Date(
                        stack.Task.StartDate.Year(),
                        stack.Task.StartDate.Month(),
                        stack.Task.StartDate.Day(),
                        0, 0, 0, 0, time.UTC,
                )

                if taskStartDate.Before(normalizedDate) </span><span class="cov0" title="0">{
                        continuations = append(continuations, stack)
                }</span>
        }

        <span class="cov0" title="0">return continuations</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package core provides core utilities for color manipulation and conversion
package core

import (
        "fmt"
        "strconv"
        "strings"
)

// HexToRGB converts a hex color string to RGB format for LaTeX compatibility.
// Accepts hex colors with or without the # prefix.
// Returns "128,128,128" (gray) for invalid hex strings.
func HexToRGB(hex string) string <span class="cov0" title="0">{
        // Remove # prefix if present
        hex = strings.TrimPrefix(hex, "#")

        // Validate hex length
        if len(hex) != 6 </span><span class="cov0" title="0">{
                return "128,128,128" // Default gray for invalid hex
        }</span>

        // Parse hex values
        <span class="cov0" title="0">r, err1 := strconv.ParseInt(hex[0:2], 16, 64)
        g, err2 := strconv.ParseInt(hex[2:4], 16, 64)
        b, err3 := strconv.ParseInt(hex[4:6], 16, 64)

        if err1 != nil || err2 != nil || err3 != nil </span><span class="cov0" title="0">{
                return "128,128,128" // Default gray on parse error
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%d,%d,%d", r, g, b)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package core provides the fundamental types and utilities for the PhD dissertation planner.
//
// This package contains:
//   - Configuration management (Config, defaults, validation)
//   - Data structures (Task, Page, Module)
//   - CSV data reading and parsing
//   - Error types with rich context
//   - Centralized logging system
//
// The package is organized into several key areas:
//
// Configuration:
//
//        Config, DefaultConfig(), and helper methods provide a flexible configuration
//        system with sensible defaults and YAML/environment variable support.
//
// Data Reading:
//
//        Reader provides CSV parsing with robust error handling and field extraction.
//
// Error Handling:
//
//        Custom error types (ConfigError, FileError, TemplateError, DataError) provide
//        contextual information for debugging. ErrorAggregator collects multiple errors.
//
// Logging:
//
//        Logger provides level-based logging (silent, info, debug) with environment
//        variable control.
//
// Example usage:
//
//        // Load configuration
//        cfg, err := core.NewConfig("base.yaml")
//        if err != nil {
//            log.Fatal(err)
//        }
//
//        // Read tasks from CSV
//        reader := core.NewReader(cfg.CSVFilePath)
//        tasks, err := reader.ReadTasks()
//        if err != nil {
//            log.Fatal(err)
//        }
//
//        // Use configuration helpers
//        dayWidth := cfg.GetDayNumberWidth()
//        if cfg.IsDebugMode() {
//            fmt.Println("Debug mode enabled")
//        }
package core

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/caarlos0/env/v6"
        "github.com/goccy/go-yaml"
)

type Config struct {
        Debug Debug

        Year                int `env:"PLANNER_YEAR"`
        WeekStart           time.Weekday
        Dotted              bool
        CalAfterSchedule    bool
        ClearTopRightCorner bool
        AMPMTime            bool
        AddLastHalfHour     bool

        // Data source configuration
        CSVFilePath string `env:"PLANNER_CSV_FILE"`
        StartYear   int    `env:"PLANNER_START_YEAR"`
        EndYear     int    `env:"PLANNER_END_YEAR"`

        // Months with tasks (populated from CSV)
        MonthsWithTasks []MonthYear

        Pages Pages

        Layout Layout

        // OutputDir is the directory where generated .tex and .pdf files will be written
        // Defaults to "build" when not provided via environment or config
        OutputDir string `env:"PLANNER_OUTPUT_DIR"`
}

type Debug struct {
        ShowFrame bool
        ShowLinks bool
}

type Pages []Page
type Page struct {
        Name         string
        RenderBlocks RenderBlocks
}

type RenderBlocks []RenderBlock

type Modules []Module
type Module struct {
        Cfg  Config
        Tpl  string
        Body interface{}
}

type RenderBlock struct {
        FuncName string
        Tpls     []string
}

type Colors struct {
        Gray      string
        LightGray string
}

// TaskColors removed - using algorithmic colors

// RGBColor removed - using algorithmic colors

type AlgorithmicColors struct {
        Proposal     string
        Laser        string
        Imaging      string
        Admin        string
        Dissertation string
        Research     string
        Publication  string
}

type LaTeX struct {
        TabColSep             string
        HeaderSideMonthsWidth string
        ArrayStretch          float64
        MonthlyCellHeight     string
        HeaderResizeBox       string
        LineThicknessDefault  string
        LineThicknessThick    string
        ColSep                string

        // Document settings
        Document Document `yaml:"document"`

        // Typography settings
        Typography Typography `yaml:"typography"`
}

type TaskStyling struct {
        // Core task appearance
        FontSize       string `yaml:"fontsize"`
        BarHeight      string `yaml:"bar_height"`
        BorderWidth    string `yaml:"border_width"`
        ShowObjectives bool   `yaml:"show_objectives"`

        // Visual styling
        BackgroundOpacity int `yaml:"background_opacity"`
        BorderOpacity     int `yaml:"border_opacity"`

        // Task box spacing and padding
        Spacing TaskStylingSpacing `yaml:"spacing"`

        // TColorBox styling for task boxes
        TColorBox TaskStylingTColorBox `yaml:"tcolorbox"`

        // Milestone-specific styling
        Milestone TaskStylingMilestone `yaml:"milestone"`
}

type TaskStylingSpacing struct {
        VerticalOffset    string `yaml:"vertical_offset"`
        ContentVspace     string `yaml:"content_vspace"`
        PaddingHorizontal string `yaml:"padding_horizontal"`
        PaddingVertical   string `yaml:"padding_vertical"`
}

type TaskStylingTColorBox struct {
        // Main task overlay boxes (spanning tasks)
        Overlay TColorBoxOverlay `yaml:"overlay"`
}

type TaskStylingMilestone struct {
        BorderWidth       string `yaml:"border_width"`
        BorderOpacity     int    `yaml:"border_opacity"`
        BackgroundOpacity int    `yaml:"background_opacity"`
}

type TColorBoxOverlay struct {
        Arc     string
        Left    string
        Right   string
        Top     string
        Bottom  string
        BoxRule string
}

type Typography struct {
        HyphenPenalty          int
        Tolerance              int
        EmergencyStretch       string
        SloppyEmergencyStretch string
}

type Spacing struct {
        TableColSep    string `yaml:"table_colsep"`
        ColorLegendSep string `yaml:"color_legend_sep"`
        Col            string `yaml:"col"`
        TaskOverlayArc string `yaml:"task_overlay_arc"`
}

type Document struct {
        FontSize  string
        ParIndent string
}

type Constraints struct {
        MaxStackHeight float64
        MinTaskHeight  float64
        MaxTaskHeight  float64
        MinTaskWidth   float64
        MaxTaskWidth   float64
        // Spacing values are hardcoded in stacking.go
        CollisionThreshold float64
        OverflowThreshold  float64
        ExpansionThreshold float64

        // Task sizing constraints
        MaxTaskWidthDays float64 `yaml:"max_task_width_days"`

        // Visual styling (inherited from layout_engine)

        // Algorithm thresholds (inherited from layout_engine)

        // Task positioning (hardcoded in layout_manager.go)
}

type Layout struct {
        Paper Paper `yaml:"paper"`

        Numbers Numbers
        Lengths Lengths
        Colors  Colors
        // TaskColors removed - using algorithmic colors
        AlgorithmicColors AlgorithmicColors
        LaTeX             LaTeX `yaml:"latex"`

        // Centralized task styling and spacing
        TaskStyling TaskStyling `yaml:"task_styling"`
        Spacing     Spacing     `yaml:"spacing"`

        Constraints  Constraints
        Calendar     Calendar
        Stacking     Stacking
        LayoutEngine LayoutEngine `yaml:"layout_engine"`
}

type Calendar struct {
        TaskKernSpacing string `yaml:"taskkernspacing"`
        // Other parameters hardcoded in calendar.go
}

type Stacking struct {
        BaseHeight float64 `yaml:"base_height"`
        MinHeight  float64 `yaml:"min_height"`
        MaxHeight  float64 `yaml:"max_height"`

        // Visual quality thresholds
        OverflowVertical   float64 `yaml:"overflow_vertical"`
        CollisionThreshold float64 `yaml:"collision_threshold"`
        // Other thresholds hardcoded in stacking.go
}

type LayoutEngine struct {
        // Task positioning multipliers (relative to day dimensions)
        InitialYPositionMultiplier float64 `yaml:"initial_y_position_multiplier"`
        TaskHeightMultiplier       float64 `yaml:"task_height_multiplier"`
        MaxTaskWidthDays           float64 `yaml:"max_task_width_days"`

        // Visual weight calculation multipliers
        DurationLongMultiplier    float64 `yaml:"duration_long_multiplier"`
        DurationShortMultiplier   float64 `yaml:"duration_short_multiplier"`
        MilestoneWeightMultiplier float64 `yaml:"milestone_weight_multiplier"`
        CategoryWeightMultiplier  float64 `yaml:"category_weight_multiplier"`

        // Urgency multipliers removed - using simplified prominence calculation

        // Quality assessment thresholds (hardcoded as constants)

        // Task rendering configuration
        TaskRendering TaskRendering `yaml:"task_rendering"`

        // Typography settings for task text (inherited from main typography)

        // Grid constraints
        GridConstraints LayoutGridConstraints `yaml:"grid_constraints"`

        // Visual styling
        // Visual styling (hardcoded in layout_manager.go)

        // Calendar layout constants
        CalendarLayout LayoutCalendarLayout `yaml:"calendar_layout"`

        // Task density calculation removed - not used in code
}

// UrgencyMultipliers struct removed - using simplified prominence calculation

type TaskRendering struct {
        DefaultSpacing   string `yaml:"default_spacing"`
        FirstTaskSpacing string `yaml:"first_task_spacing"`
        DefaultHeight    string `yaml:"default_height"`
        FirstTaskHeight  string `yaml:"first_task_height"`
        VerticalSpacing  string `yaml:"vertical_spacing"`
}

// LayoutTypography struct removed - not used in code

type LayoutGridConstraints struct {
        MinTaskSpacing     float64 `yaml:"min_task_spacing"`
        MaxTaskSpacing     float64 `yaml:"max_task_spacing"`
        MinRowHeight       float64 `yaml:"min_row_height"`
        MaxRowHeight       float64 `yaml:"max_row_height"`
        MinColumnWidth     float64 `yaml:"min_column_width"`
        MaxColumnWidth     float64 `yaml:"max_column_width"`
        GridResolution     float64 `yaml:"grid_resolution"`
        AlignmentTolerance float64 `yaml:"alignment_tolerance"`
        CollisionBuffer    float64 `yaml:"collision_buffer"`
        TransitionBuffer   float64 `yaml:"transition_buffer"`
}

// LayoutVisualStyling removed - values are hardcoded in layout_manager.go

type LayoutCalendarLayout struct {
        DayNumberWidth        string `yaml:"day_number_width"`
        DayContentMargin      string `yaml:"day_content_margin"`
        TaskCellMargin        string `yaml:"task_cell_margin"`
        TaskCellSpacing       string `yaml:"task_cell_spacing"`
        DayCellMinipageWidth  string `yaml:"day_cell_minipage_width"`
        HeaderAngleSizeOffset string `yaml:"header_angle_size_offset"`
}

// LayoutDensityCalculation struct removed - not used in code

type Numbers struct {
        ArrayStretch float64
}

type Lengths struct {
        TabColSep             string
        LineThicknessDefault  string
        LineThicknessThick    string
        LineHeightButLine     string
        TwoColSep             string
        TriColSep             string
        FiveColSep            string
        MonthlyCellHeight     string
        HeaderResizeBox       string
        HeaderSideMonthsWidth string
        MonthlySpring         string
}

type Paper struct {
        Width  string `env:"PLANNER_LAYOUT_PAPER_WIDTH"`
        Height string `env:"PLANNER_LAYOUT_PAPER_HEIGHT"`

        Margin Margin

        ReverseMargins bool
        MarginParWidth string
        MarginParSep   string
}

type Margin struct {
        Top    string `env:"PLANNER_LAYOUT_PAPER_MARGIN_TOP"`
        Bottom string `env:"PLANNER_LAYOUT_PAPER_MARGIN_BOTTOM"`
        Left   string `env:"PLANNER_LAYOUT_PAPER_MARGIN_LEFT"`
        Right  string `env:"PLANNER_LAYOUT_PAPER_MARGIN_RIGHT"`
}

// Composer is a function type for generating modules
type Composer func(cfg Config, tpls []string) (Modules, error)

// ComposerMap maps function names to their implementations
// This will be populated by the app package to avoid circular imports
var ComposerMap = map[string]Composer{}

// FilterUniqueModules removes duplicate modules based on template name
func FilterUniqueModules(array []Module) []Module <span class="cov1" title="1">{
        filtered := make([]Module, 0)
        found := map[string]bool{}

        for _, val := range array </span><span class="cov10" title="3">{
                if _, present := found[val.Tpl]; !present </span><span class="cov6" title="2">{
                        filtered = append(filtered, val)
                        found[val.Tpl] = true
                }</span>
        }

        <span class="cov1" title="1">return filtered</span>
}

// NewConfig creates a new configuration from config files and environment variables
// Starts with sensible defaults and overlays file and environment configuration
func NewConfig(pathConfigs ...string) (Config, error) <span class="cov0" title="0">{
        var (
                bts []byte
                err error
        )

        // Start with default configuration
        cfg := DefaultConfig()

        // Overlay configuration from files
        for _, filepath := range pathConfigs </span><span class="cov0" title="0">{
                // Skip missing files instead of failing
                if bts, err = os.ReadFile(strings.ToLower(filepath)); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                // File doesn't exist, skip it
                                continue</span>
                        }
                        <span class="cov0" title="0">return cfg, fmt.Errorf("read file: %w", err)</span>
                }

                // Skip empty files
                <span class="cov0" title="0">if len(strings.TrimSpace(string(bts))) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if err = yaml.Unmarshal(bts, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                        return cfg, fmt.Errorf("yaml unmarshal: %w", err)
                }</span>
        }

        // Overlay environment variables
        <span class="cov0" title="0">if err = env.Parse(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, fmt.Errorf("env parse: %w", err)
        }</span>

        // Apply fallbacks for unset values
        <span class="cov0" title="0">if cfg.Year == 0 </span><span class="cov0" title="0">{
                cfg.Year = time.Now().Year()
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(cfg.OutputDir) == "" </span><span class="cov0" title="0">{
                cfg.OutputDir = Defaults.DefaultOutputDir
        }</span>

        // Set defaults for layout engine configuration
        <span class="cov0" title="0">cfg.setLayoutEngineDefaults()

        // Set algorithmic colors for predefined categories
        cfg.setAlgorithmicColors()

        // Validate layout engine configuration
        if err := cfg.validateLayoutEngineConfig(); err != nil </span><span class="cov0" title="0">{
                return cfg, fmt.Errorf("layout engine config validation failed: %w", err)
        }</span>

        // If CSV file is provided, determine date range dynamically
        <span class="cov0" title="0">if cfg.CSVFilePath != "" </span><span class="cov0" title="0">{
                if err := cfg.setDateRangeFromCSV(); err != nil </span><span class="cov0" title="0">{
                        return cfg, fmt.Errorf("failed to set date range from CSV: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return cfg, nil</span>
}

// setDateRangeFromCSV reads the CSV file and sets the start and end years
func (cfg *Config) setDateRangeFromCSV() error <span class="cov0" title="0">{
        reader := NewReader(cfg.CSVFilePath)

        // Read tasks once and derive both date range and months from the same slice
        tasks, err := reader.ReadTasks()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read tasks: %w", err)
        }</span>

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no tasks found in CSV file")
        }</span>

        // Compute earliest/latest dates and collect months with tasks
        <span class="cov0" title="0">earliest := tasks[0].StartDate
        latest := tasks[0].EndDate
        monthsSet := make(map[MonthYear]bool)

        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.StartDate.Before(earliest) </span><span class="cov0" title="0">{
                        earliest = task.StartDate
                }</span>
                <span class="cov0" title="0">if task.EndDate.After(latest) </span><span class="cov0" title="0">{
                        latest = task.EndDate
                }</span>

                // Walk months from task start to end and add to set
                <span class="cov0" title="0">current := time.Date(task.StartDate.Year(), task.StartDate.Month(), 1, 0, 0, 0, 0, time.UTC)
                end := time.Date(task.EndDate.Year(), task.EndDate.Month(), 1, 0, 0, 0, 0, time.UTC)
                for !current.After(end) </span><span class="cov0" title="0">{
                        monthsSet[MonthYear{Year: current.Year(), Month: current.Month()}] = true
                        current = current.AddDate(0, 1, 0)
                }</span>
        }

        // Assign year range
        <span class="cov0" title="0">cfg.StartYear = earliest.Year()
        cfg.EndYear = latest.Year()

        // Convert months set to a sorted slice for deterministic ordering
        months := make([]MonthYear, 0, len(monthsSet))
        for m := range monthsSet </span><span class="cov0" title="0">{
                months = append(months, m)
        }</span>

        // Sort by year, then by month
        <span class="cov0" title="0">for i := 0; i &lt; len(months)-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(months)-i-1; j++ </span><span class="cov0" title="0">{
                        if months[j].Year &gt; months[j+1].Year ||
                                (months[j].Year == months[j+1].Year &amp;&amp; months[j].Month &gt; months[j+1].Month) </span><span class="cov0" title="0">{
                                months[j], months[j+1] = months[j+1], months[j]
                        }</span>
                }
        }
        <span class="cov0" title="0">cfg.MonthsWithTasks = months

        // Limit year range to only years present in months (keeps behavior consistent)
        if len(months) &gt; 0 </span><span class="cov0" title="0">{
                yearSet := make(map[int]bool)
                for _, my := range months </span><span class="cov0" title="0">{
                        yearSet[my.Year] = true
                }</span>
                <span class="cov0" title="0">years := make([]int, 0, len(yearSet))
                for y := range yearSet </span><span class="cov0" title="0">{
                        years = append(years, y)
                }</span>
                // Sort years
                <span class="cov0" title="0">for i := 0; i &lt; len(years)-1; i++ </span><span class="cov0" title="0">{
                        for j := 0; j &lt; len(years)-i-1; j++ </span><span class="cov0" title="0">{
                                if years[j] &gt; years[j+1] </span><span class="cov0" title="0">{
                                        years[j], years[j+1] = years[j+1], years[j]
                                }</span>
                        }
                }
                <span class="cov0" title="0">cfg.StartYear = years[0]
                cfg.EndYear = years[len(years)-1]</span>
        }

        // Update the main Year field to the start year if not explicitly set
        <span class="cov0" title="0">if cfg.Year == time.Now().Year() </span><span class="cov0" title="0">{
                cfg.Year = cfg.StartYear
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setAlgorithmicColors sets the algorithmic colors for predefined categories
func (cfg *Config) setAlgorithmicColors() <span class="cov0" title="0">{
        cfg.Layout.AlgorithmicColors = AlgorithmicColors{
                Proposal:     HexToRGB(GenerateCategoryColor("PROPOSAL")),
                Laser:        HexToRGB(GenerateCategoryColor("LASER")),
                Imaging:      HexToRGB(GenerateCategoryColor("IMAGING")),
                Admin:        HexToRGB(GenerateCategoryColor("ADMIN")),
                Dissertation: HexToRGB(GenerateCategoryColor("DISSERTATION")),
                Research:     HexToRGB(GenerateCategoryColor("RESEARCH")),
                Publication:  HexToRGB(GenerateCategoryColor("PUBLICATION")),
        }
}</span>

// getStringWithDefault returns the config value if it's not empty, otherwise the default
func (c *Config) getStringWithDefault(value, defaultValue string) string <span class="cov6" title="2">{
        if value != "" </span><span class="cov6" title="2">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// getIntWithDefault returns the config value if it's greater than 0, otherwise the default
func (c *Config) getIntWithDefault(value, defaultValue int) int <span class="cov6" title="2">{
        if value &gt; 0 </span><span class="cov6" title="2">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// getTrimmedStringWithDefault returns the trimmed config value if it's not empty, otherwise the default
func (c *Config) getTrimmedStringWithDefault(value, defaultValue string) string <span class="cov1" title="1">{
        if strings.TrimSpace(value) != "" </span><span class="cov1" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// GetYears returns a slice of years to generate planners for
func (cfg *Config) GetYears() []int <span class="cov0" title="0">{
        if cfg.StartYear == 0 || cfg.EndYear == 0 </span><span class="cov0" title="0">{
                // Fallback to single year
                return []int{cfg.Year}
        }</span>

        <span class="cov0" title="0">years := make([]int, 0, cfg.EndYear-cfg.StartYear+1)
        for year := cfg.StartYear; year &lt;= cfg.EndYear; year++ </span><span class="cov0" title="0">{
                years = append(years, year)
        }</span>

        <span class="cov0" title="0">return years</span>
}

// setLayoutEngineDefaults sets default values for layout engine configuration
func (cfg *Config) setLayoutEngineDefaults() <span class="cov0" title="0">{
        cfg.setLayoutEngineMultipliersDefaults()
        cfg.setTaskRenderingDefaults()
        cfg.setTypographyDefaults()
        cfg.setGridConstraintsDefaults()
        cfg.setCalendarLayoutDefaults()
}</span>

// setLayoutEngineMultipliersDefaults sets default values for layout engine multipliers
func (cfg *Config) setLayoutEngineMultipliersDefaults() <span class="cov0" title="0">{
        // * Set defaults for layout engine if not already set
        if cfg.Layout.LayoutEngine.InitialYPositionMultiplier == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.InitialYPositionMultiplier = 0.1
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.TaskHeightMultiplier == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.TaskHeightMultiplier = 0.6
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.MaxTaskWidthDays == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.MaxTaskWidthDays = 7.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.DurationLongMultiplier == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.DurationLongMultiplier = 1.2
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.DurationShortMultiplier == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.DurationShortMultiplier = 0.8
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.MilestoneWeightMultiplier == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.MilestoneWeightMultiplier = 1.5
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.CategoryWeightMultiplier == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CategoryWeightMultiplier = 1.0
        }</span>
}

// setTaskRenderingDefaults sets default values for task rendering configuration
func (cfg *Config) setTaskRenderingDefaults() <span class="cov0" title="0">{
        // * Set task rendering defaults
        if cfg.Layout.LayoutEngine.TaskRendering.DefaultSpacing == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.TaskRendering.DefaultSpacing = "0.8ex"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.TaskRendering.FirstTaskSpacing == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.TaskRendering.FirstTaskSpacing = "0.5ex"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.TaskRendering.DefaultHeight == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.TaskRendering.DefaultHeight = "3.0ex"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.TaskRendering.FirstTaskHeight == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.TaskRendering.FirstTaskHeight = "3.5ex"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.TaskRendering.VerticalSpacing == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.TaskRendering.VerticalSpacing = "0.1ex"
        }</span>
}

// setTypographyDefaults sets default values for typography settings
func (cfg *Config) setTypographyDefaults() <span class="cov0" title="0">{
        // * Set typography defaults (using main typography settings)
        if cfg.Layout.LaTeX.Typography.HyphenPenalty == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LaTeX.Typography.HyphenPenalty = 50
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LaTeX.Typography.Tolerance == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LaTeX.Typography.Tolerance = 1000
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LaTeX.Typography.EmergencyStretch == "" </span><span class="cov0" title="0">{
                cfg.Layout.LaTeX.Typography.EmergencyStretch = "2em"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LaTeX.Typography.SloppyEmergencyStretch == "" </span><span class="cov0" title="0">{
                cfg.Layout.LaTeX.Typography.SloppyEmergencyStretch = "3em"
        }</span>
}

// setGridConstraintsDefaults sets default values for grid constraints
func (cfg *Config) setGridConstraintsDefaults() <span class="cov0" title="0">{
        // * Set grid constraints defaults
        if cfg.Layout.LayoutEngine.GridConstraints.MinTaskSpacing == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.MinTaskSpacing = 1.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MaxTaskSpacing == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.MaxTaskSpacing = 10.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MinRowHeight == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.MinRowHeight = 8.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MaxRowHeight == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.MaxRowHeight = 20.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MinColumnWidth == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.MinColumnWidth = 5.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MaxColumnWidth == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.MaxColumnWidth = 50.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.GridResolution == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.GridResolution = 1.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.AlignmentTolerance == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.AlignmentTolerance = 0.5
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.CollisionBuffer == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.CollisionBuffer = 2.0
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.TransitionBuffer == 0 </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.GridConstraints.TransitionBuffer = 2.0
        }</span>
}

// setCalendarLayoutDefaults sets default values for calendar layout constants
func (cfg *Config) setCalendarLayoutDefaults() <span class="cov0" title="0">{
        // * Set calendar layout defaults
        if cfg.Layout.LayoutEngine.CalendarLayout.DayNumberWidth == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CalendarLayout.DayNumberWidth = "6mm"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.CalendarLayout.DayContentMargin == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CalendarLayout.DayContentMargin = "8mm"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.CalendarLayout.TaskCellMargin == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CalendarLayout.TaskCellMargin = "8mm"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.CalendarLayout.TaskCellSpacing == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CalendarLayout.TaskCellSpacing = "6mm"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.CalendarLayout.DayCellMinipageWidth == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CalendarLayout.DayCellMinipageWidth = "6mm"
        }</span>
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.CalendarLayout.HeaderAngleSizeOffset == "" </span><span class="cov0" title="0">{
                cfg.Layout.LayoutEngine.CalendarLayout.HeaderAngleSizeOffset = "0.86pt"
        }</span>
}

// validateLayoutEngineConfig validates the layout engine configuration
func (cfg *Config) validateLayoutEngineConfig() error <span class="cov0" title="0">{
        // * Validate multiplier ranges (0.0 to 10.0)
        multipliers := []struct {
                name  string
                value float64
        }{
                {"initial_y_position_multiplier", cfg.Layout.LayoutEngine.InitialYPositionMultiplier},
                {"task_height_multiplier", cfg.Layout.LayoutEngine.TaskHeightMultiplier},
                {"max_task_width_days", cfg.Layout.LayoutEngine.MaxTaskWidthDays},
                {"duration_long_multiplier", cfg.Layout.LayoutEngine.DurationLongMultiplier},
                {"duration_short_multiplier", cfg.Layout.LayoutEngine.DurationShortMultiplier},
                {"milestone_weight_multiplier", cfg.Layout.LayoutEngine.MilestoneWeightMultiplier},
                {"category_weight_multiplier", cfg.Layout.LayoutEngine.CategoryWeightMultiplier},
        }

        for _, m := range multipliers </span><span class="cov0" title="0">{
                if m.value &lt; 0.0 || m.value &gt; 10.0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid %s: %f (must be between 0.0 and 10.0)", m.name, m.value)
                }</span>
        }

        // Quality threshold validation removed - using hardcoded constants

        // Urgency multiplier validation removed - using simplified prominence calculation

        // * Validate grid constraints
        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MinTaskSpacing &gt; cfg.Layout.LayoutEngine.GridConstraints.MaxTaskSpacing </span><span class="cov0" title="0">{
                return fmt.Errorf("min_task_spacing (%f) cannot be greater than max_task_spacing (%f)",
                        cfg.Layout.LayoutEngine.GridConstraints.MinTaskSpacing,
                        cfg.Layout.LayoutEngine.GridConstraints.MaxTaskSpacing)
        }</span>

        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MinRowHeight &gt; cfg.Layout.LayoutEngine.GridConstraints.MaxRowHeight </span><span class="cov0" title="0">{
                return fmt.Errorf("min_row_height (%f) cannot be greater than max_row_height (%f)",
                        cfg.Layout.LayoutEngine.GridConstraints.MinRowHeight,
                        cfg.Layout.LayoutEngine.GridConstraints.MaxRowHeight)
        }</span>

        <span class="cov0" title="0">if cfg.Layout.LayoutEngine.GridConstraints.MinColumnWidth &gt; cfg.Layout.LayoutEngine.GridConstraints.MaxColumnWidth </span><span class="cov0" title="0">{
                return fmt.Errorf("min_column_width (%f) cannot be greater than max_column_width (%f)",
                        cfg.Layout.LayoutEngine.GridConstraints.MinColumnWidth,
                        cfg.Layout.LayoutEngine.GridConstraints.MaxColumnWidth)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ============================================================================
// Configuration Helper Methods
// ============================================================================

// GetDayNumberWidth returns the day number width with fallback to default
func (c *Config) GetDayNumberWidth() string <span class="cov1" title="1">{
        return c.getStringWithDefault(c.Layout.LayoutEngine.CalendarLayout.DayNumberWidth, Defaults.DayNumberWidth)
}</span>

// GetDayContentMargin returns the day content margin with fallback to default
func (c *Config) GetDayContentMargin() string <span class="cov1" title="1">{
        return c.getStringWithDefault(c.Layout.LayoutEngine.CalendarLayout.DayContentMargin, Defaults.DayContentMargin)
}</span>

// GetTaskCellMargin returns the task cell margin with fallback to default
func (c *Config) GetTaskCellMargin() string <span class="cov0" title="0">{
        return c.getStringWithDefault(c.Layout.LayoutEngine.CalendarLayout.TaskCellMargin, Defaults.TaskCellMargin)
}</span>

// GetTaskCellSpacing returns the task cell spacing with fallback to default
func (c *Config) GetTaskCellSpacing() string <span class="cov0" title="0">{
        return c.getStringWithDefault(c.Layout.LayoutEngine.CalendarLayout.TaskCellSpacing, Defaults.TaskCellSpacing)
}</span>

// GetHeaderAngleSizeOffset returns the header angle size offset with fallback
func (c *Config) GetHeaderAngleSizeOffset() string <span class="cov0" title="0">{
        return c.getStringWithDefault(c.Layout.LayoutEngine.CalendarLayout.HeaderAngleSizeOffset, Defaults.HeaderAngleSizeOffset)
}</span>

// GetHyphenPenalty returns the hyphen penalty with fallback to default
func (c *Config) GetHyphenPenalty() int <span class="cov1" title="1">{
        return c.getIntWithDefault(c.Layout.LaTeX.Typography.HyphenPenalty, Defaults.HyphenPenalty)
}</span>

// GetTolerance returns the tolerance with fallback to default
func (c *Config) GetTolerance() int <span class="cov1" title="1">{
        return c.getIntWithDefault(c.Layout.LaTeX.Typography.Tolerance, Defaults.Tolerance)
}</span>

// GetEmergencyStretch returns the emergency stretch with fallback to default
func (c *Config) GetEmergencyStretch() string <span class="cov0" title="0">{
        if c.Layout.LaTeX.Typography.SloppyEmergencyStretch != "" </span><span class="cov0" title="0">{
                return c.Layout.LaTeX.Typography.SloppyEmergencyStretch
        }</span>
        <span class="cov0" title="0">if c.Layout.LaTeX.Typography.EmergencyStretch != "" </span><span class="cov0" title="0">{
                return c.Layout.LaTeX.Typography.EmergencyStretch
        }</span>
        <span class="cov0" title="0">return Defaults.EmergencyStretch</span>
}

// GetOutputDir returns the output directory with fallback to default
func (c *Config) GetOutputDir() string <span class="cov1" title="1">{
        return c.getTrimmedStringWithDefault(c.OutputDir, Defaults.DefaultOutputDir)
}</span>

// IsDebugMode returns true if any debug flag is enabled
func (c *Config) IsDebugMode() bool <span class="cov6" title="2">{
        return c.Debug.ShowFrame || c.Debug.ShowLinks
}</span>

// GetYear returns the configured year or current year if not set
func (c *Config) GetYear() int <span class="cov6" title="2">{
        if c.Year &gt; 0 </span><span class="cov1" title="1">{
                return c.Year
        }</span>
        <span class="cov1" title="1">return time.Now().Year()</span>
}

// HasCSVData returns true if a CSV file path is configured
func (c *Config) HasCSVData() bool <span class="cov6" title="2">{
        return strings.TrimSpace(c.CSVFilePath) != ""
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package core - Defaults provides centralized default values for all configuration.
//
// This module serves as the single source of truth for all default configuration
// values used throughout the application. When no configuration is provided or
// when values are missing, these defaults are used.
//
// Key functions:
//   - DefaultConfig(): Complete configuration with all defaults
//   - DefaultLayout(): Layout configuration defaults
//   - DefaultLaTeX(): LaTeX-specific defaults
//   - DefaultTypography(): Typography settings defaults
//   - DefaultLayoutCalendarLayout(): Calendar layout defaults
//
// The Defaults struct provides easy access to commonly used default values
// as constants, useful for fallback logic throughout the codebase.
//
// Example usage:
//
//        // Get a complete default configuration
//        cfg := core.DefaultConfig()
//
//        // Override specific values
//        cfg.Year = 2025
//        cfg.OutputDir = "custom/output"
//
//        // Access default constants directly
//        width := core.Defaults.DayNumberWidth  // "6mm"
//        color := core.Defaults.DefaultTaskColor // "224,50,212"
//
// Design philosophy:
//   - Sensible defaults that work for most use cases
//   - Easy to understand and modify in one place
//   - No magic numbers scattered throughout code
//   - New users can see all options with defaults
package core

import "time"

// DefaultConfig returns a Config with sensible defaults
// This serves as the baseline configuration before loading from YAML or environment
func DefaultConfig() Config <span class="cov6" title="3">{
        return Config{
                Debug: Debug{
                        ShowFrame: false,
                        ShowLinks: false,
                },
                Year:                time.Now().Year(),
                WeekStart:           time.Sunday,
                Dotted:              false,
                CalAfterSchedule:    false,
                ClearTopRightCorner: false,
                AMPMTime:            false,
                AddLastHalfHour:     false,
                OutputDir:           "generated",
                Layout:              DefaultLayout(),
        }
}</span>

// DefaultLayout returns a Layout with sensible defaults
func DefaultLayout() Layout <span class="cov7" title="4">{
        return Layout{
                Paper: Paper{
                        Width:  "8.5in",
                        Height: "11in",
                        Margin: Margin{
                                Top:    "1in",
                                Bottom: "1in",
                                Left:   "1in",
                                Right:  "1in",
                        },
                        MarginParWidth: "1in",
                        MarginParSep:   "0.2in",
                        ReverseMargins: false,
                },
                LaTeX:        DefaultLaTeX(),
                LayoutEngine: DefaultLayoutEngine(),
        }
}</span>

// DefaultLaTeX returns LaTeX configuration with sensible defaults
func DefaultLaTeX() LaTeX <span class="cov9" title="5">{
        return LaTeX{
                TabColSep:             "1pt",
                HeaderSideMonthsWidth: "3em",
                ArrayStretch:          1.0,
                MonthlyCellHeight:     "4em",
                HeaderResizeBox:       "0.9",
                LineThicknessDefault:  "0.4pt",
                LineThicknessThick:    "1.2pt",
                ColSep:                "3pt",
                Document:              DefaultDocument(),
                Typography:            DefaultTypography(),
        }
}</span>

// DefaultDocument returns Document configuration defaults
func DefaultDocument() Document <span class="cov10" title="6">{
        return Document{
                FontSize:  "10pt",
                ParIndent: "0pt",
        }
}</span>

// DefaultTypography returns Typography configuration defaults
func DefaultTypography() Typography <span class="cov10" title="6">{
        return Typography{
                HyphenPenalty:          50,
                Tolerance:              1000,
                EmergencyStretch:       "3em",
                SloppyEmergencyStretch: "3em",
        }
}</span>

// DefaultLayoutEngine returns LayoutEngine configuration defaults
func DefaultLayoutEngine() LayoutEngine <span class="cov7" title="4">{
        return LayoutEngine{
                CalendarLayout: DefaultLayoutCalendarLayout(),
        }
}</span>

// DefaultLayoutCalendarLayout returns LayoutCalendarLayout configuration defaults
func DefaultLayoutCalendarLayout() LayoutCalendarLayout <span class="cov9" title="5">{
        return LayoutCalendarLayout{
                DayNumberWidth:        "6mm",
                DayContentMargin:      "8mm",
                TaskCellMargin:        "1mm",
                TaskCellSpacing:       "0.5mm",
                DayCellMinipageWidth:  "8mm",
                HeaderAngleSizeOffset: "2pt",
        }
}</span>

// DefaultTaskStyling returns TaskStyling configuration defaults
func DefaultTaskStyling() TaskStyling <span class="cov0" title="0">{
        return TaskStyling{
                FontSize:          "\\footnotesize",
                BarHeight:         "1.5mm",
                BorderWidth:       "0.5pt",
                ShowObjectives:    true,
                BackgroundOpacity: 20,
                BorderOpacity:     80,
                Spacing:           DefaultTaskStylingSpacing(),
                TColorBox:         DefaultTaskStylingTColorBox(),
        }
}</span>

// DefaultTaskStylingSpacing returns TaskStylingSpacing defaults
func DefaultTaskStylingSpacing() TaskStylingSpacing <span class="cov0" title="0">{
        return TaskStylingSpacing{
                VerticalOffset:    "0.2ex",
                ContentVspace:     "0.2ex",
                PaddingHorizontal: "2pt",
                PaddingVertical:   "1pt",
        }
}</span>

// DefaultTaskStylingTColorBox returns TaskStylingTColorBox defaults
func DefaultTaskStylingTColorBox() TaskStylingTColorBox <span class="cov0" title="0">{
        return TaskStylingTColorBox{
                Overlay: TColorBoxOverlay{
                        Arc:     "2pt",
                        Left:    "1pt",
                        Right:   "1pt",
                        Top:     "1pt",
                        Bottom:  "1pt",
                        BoxRule: "0.5pt",
                },
        }
}</span>

// DefaultColors returns Colors configuration defaults
func DefaultColors() Colors <span class="cov0" title="0">{
        return Colors{
                Gray:      "0.5",
                LightGray: "0.8",
        }
}</span>

// ConfigDefaults holds all default values as constants for easy reference
type ConfigDefaults struct {
        // Calendar layout defaults
        DayNumberWidth        string
        DayContentMargin      string
        TaskCellMargin        string
        TaskCellSpacing       string
        HeaderAngleSizeOffset string

        // Typography defaults
        HyphenPenalty    int
        Tolerance        int
        EmergencyStretch string

        // Output defaults
        DefaultOutputDir string

        // Task color defaults
        DefaultTaskColor string
}

// Defaults provides easy access to default values
var Defaults = ConfigDefaults{
        // Calendar layout
        DayNumberWidth:        "6mm",
        DayContentMargin:      "8mm",
        TaskCellMargin:        "1mm",
        TaskCellSpacing:       "0.5mm",
        HeaderAngleSizeOffset: "2pt",

        // Typography
        HyphenPenalty:    50,
        Tolerance:        1000,
        EmergencyStretch: "3em",

        // Output
        DefaultOutputDir: "generated",

        // Task colors
        DefaultTaskColor: "224,50,212", // Magenta fallback
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package core - Errors provides custom error types with rich contextual information.
//
// This module defines structured error types for different failure scenarios:
//
// ConfigError: Configuration loading/validation failures
//   - Includes file path, field name, and descriptive message
//   - Use NewConfigError() to create with proper wrapping
//
// FileError: File operation failures
//   - Includes file path, operation type, and underlying error
//   - Use NewFileError() for consistent file error reporting
//
// TemplateError: Template processing failures
//   - Includes template name, line number, and context
//   - Use NewTemplateError() for template-specific errors
//
// DataError: Data processing failures
//   - Includes source, row, column, and descriptive message
//   - Use NewDataError() for CSV and data parsing errors
//
// ErrorAggregator: Collect and report multiple errors
//   - Distinguishes between errors (fatal) and warnings (non-fatal)
//   - Provides comprehensive summaries of all issues
//   - Use NewErrorAggregator() to collect errors during batch operations
//
// All error types implement error interface and support error wrapping with Unwrap().
//
// Example usage:
//
//        // Configuration error
//        err := core.NewConfigError("base.yaml", "weekstart", "invalid value", parseErr)
//
//        // File error
//        err := core.NewFileError("/path/to/file", "read", ioErr)
//
//        // Aggregate multiple errors
//        agg := core.NewErrorAggregator()
//        agg.AddError(err1)
//        agg.AddWarning(warn1)
//        fmt.Println(agg.Summary())
package core

import (
        "fmt"
        "strings"
)

// ConfigError represents an error that occurred during configuration loading or validation
type ConfigError struct {
        File    string // Configuration file that caused the error
        Field   string // Specific field that caused the error (optional)
        Message string // Human-readable error message
        Err     error  // Underlying error (optional)
}

func (e *ConfigError) Error() string <span class="cov3" title="2">{
        if e.Field != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("config error in %s, field '%s': %s", e.File, e.Field, e.Message)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("config error in %s: %s", e.File, e.Message)</span>
}

func (e *ConfigError) Unwrap() error <span class="cov1" title="1">{
        return e.Err
}</span>

// NewConfigError creates a new configuration error
func NewConfigError(file, field, message string, err error) *ConfigError <span class="cov3" title="2">{
        return &amp;ConfigError{
                File:    file,
                Field:   field,
                Message: message,
                Err:     err,
        }
}</span>

// FileError represents an error that occurred during file operations
type FileError struct {
        Path      string // File path
        Operation string // Operation that failed (read, write, open, etc.)
        Err       error  // Underlying error
}

func (e *FileError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("file error during %s of %s: %v", e.Operation, e.Path, e.Err)
}</span>

func (e *FileError) Unwrap() error <span class="cov1" title="1">{
        return e.Err
}</span>

// NewFileError creates a new file error
func NewFileError(path, operation string, err error) *FileError <span class="cov1" title="1">{
        return &amp;FileError{
                Path:      path,
                Operation: operation,
                Err:       err,
        }
}</span>

// TemplateError represents an error that occurred during template processing
type TemplateError struct {
        Template string // Template name
        Line     int    // Line number (if known)
        Message  string // Error message
        Err      error  // Underlying error
}

func (e *TemplateError) Error() string <span class="cov3" title="2">{
        if e.Line &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("template error in %s at line %d: %s", e.Template, e.Line, e.Message)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("template error in %s: %s", e.Template, e.Message)</span>
}

func (e *TemplateError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewTemplateError creates a new template error
func NewTemplateError(template string, line int, message string, err error) *TemplateError <span class="cov3" title="2">{
        return &amp;TemplateError{
                Template: template,
                Line:     line,
                Message:  message,
                Err:      err,
        }
}</span>

// DataError represents an error that occurred during data processing
type DataError struct {
        Source  string // Data source (CSV file, database, etc.)
        Row     int    // Row number (if applicable)
        Column  string // Column name (if applicable)
        Message string // Error message
        Err     error  // Underlying error
}

func (e *DataError) Error() string <span class="cov4" title="3">{
        if e.Row &gt; 0 &amp;&amp; e.Column != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("data error in %s at row %d, column '%s': %s", e.Source, e.Row, e.Column, e.Message)
        }</span> else<span class="cov3" title="2"> if e.Row &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("data error in %s at row %d: %s", e.Source, e.Row, e.Message)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("data error in %s: %s", e.Source, e.Message)</span>
}

func (e *DataError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewDataError creates a new data error
func NewDataError(source string, row int, column, message string, err error) *DataError <span class="cov4" title="3">{
        return &amp;DataError{
                Source:  source,
                Row:     row,
                Column:  column,
                Message: message,
                Err:     err,
        }
}</span>

// ErrorAggregator collects multiple errors and provides summary reporting
type ErrorAggregator struct {
        Errors   []error
        Warnings []error
}

// NewErrorAggregator creates a new error aggregator
func NewErrorAggregator() *ErrorAggregator <span class="cov10" title="14">{
        return &amp;ErrorAggregator{
                Errors:   make([]error, 0),
                Warnings: make([]error, 0),
        }
}</span>

// AddError adds an error to the aggregator
func (ea *ErrorAggregator) AddError(err error) <span class="cov7" title="6">{
        if err != nil </span><span class="cov7" title="6">{
                ea.Errors = append(ea.Errors, err)
        }</span>
}

// AddWarning adds a warning to the aggregator
func (ea *ErrorAggregator) AddWarning(err error) <span class="cov5" title="4">{
        if err != nil </span><span class="cov5" title="4">{
                ea.Warnings = append(ea.Warnings, err)
        }</span>
}

// HasErrors returns true if there are any errors
func (ea *ErrorAggregator) HasErrors() bool <span class="cov7" title="6">{
        return len(ea.Errors) &gt; 0
}</span>

// HasWarnings returns true if there are any warnings
func (ea *ErrorAggregator) HasWarnings() bool <span class="cov5" title="4">{
        return len(ea.Warnings) &gt; 0
}</span>

// ErrorCount returns the number of errors
func (ea *ErrorAggregator) ErrorCount() int <span class="cov8" title="8">{
        return len(ea.Errors)
}</span>

// WarningCount returns the number of warnings
func (ea *ErrorAggregator) WarningCount() int <span class="cov8" title="8">{
        return len(ea.Warnings)
}</span>

// Error implements the error interface, returns first error
func (ea *ErrorAggregator) Error() string <span class="cov4" title="3">{
        if len(ea.Errors) == 0 </span><span class="cov1" title="1">{
                return "no errors"
        }</span>
        <span class="cov3" title="2">if len(ea.Errors) == 1 </span><span class="cov1" title="1">{
                return ea.Errors[0].Error()
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%d errors occurred (first: %v)", len(ea.Errors), ea.Errors[0])</span>
}

// Summary returns a comprehensive summary of all errors and warnings
func (ea *ErrorAggregator) Summary() string <span class="cov1" title="1">{
        if !ea.HasErrors() &amp;&amp; !ea.HasWarnings() </span><span class="cov0" title="0">{
                return "No errors or warnings"
        }</span>

        <span class="cov1" title="1">var summary strings.Builder

        if ea.HasErrors() </span><span class="cov1" title="1">{
                summary.WriteString(fmt.Sprintf("Errors (%d):\n", len(ea.Errors)))
                for i, err := range ea.Errors </span><span class="cov1" title="1">{
                        summary.WriteString(fmt.Sprintf("  %d. %v\n", i+1, err))
                }</span>
        }

        <span class="cov1" title="1">if ea.HasWarnings() </span><span class="cov1" title="1">{
                if ea.HasErrors() </span><span class="cov1" title="1">{
                        summary.WriteString("\n")
                }</span>
                <span class="cov1" title="1">summary.WriteString(fmt.Sprintf("Warnings (%d):\n", len(ea.Warnings)))
                for i, err := range ea.Warnings </span><span class="cov1" title="1">{
                        summary.WriteString(fmt.Sprintf("  %d. %v\n", i+1, err))
                }</span>
        }

        <span class="cov1" title="1">return summary.String()</span>
}

// Clear clears all errors and warnings
func (ea *ErrorAggregator) Clear() <span class="cov8" title="8">{
        ea.Errors = make([]error, 0)
        ea.Warnings = make([]error, 0)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package core - Logger provides centralized logging with level-based control.
//
// The logging system supports three levels:
//   - silent: No output
//   - info: Informational messages (default)
//   - debug: Detailed debugging information
//
// Control logging via environment variables:
//   - PLANNER_SILENT=1: Suppress all output (backward compatible)
//   - PLANNER_LOG_LEVEL=silent|info|debug: Explicit level control
//
// Example usage:
//
//        logger := core.NewDefaultLogger()
//        logger.Info("Processing file: %s", filename)
//        logger.Debug("Detailed state: %+v", state)
//        logger.Warn("Potential issue: %s", warning)
//        logger.Error("Operation failed: %v", err)
//
//        // Check if silent mode is active
//        if core.IsSilent() {
//            // Skip expensive logging operations
//        }
package core

import (
        "fmt"
        "io"
        "log"
        "os"
        "strings"
)

const (
        // LogLevelSilent suppresses all log output
        LogLevelSilent = "silent"
        // LogLevelInfo shows informational messages
        LogLevelInfo = "info"
        // LogLevelDebug shows detailed debugging information
        LogLevelDebug = "debug"

        // Environment variables for logging control
        envPlannerSilent   = "PLANNER_SILENT"
        envPlannerLogLevel = "PLANNER_LOG_LEVEL"
)

// Logger provides centralized logging functionality with silent mode support
type Logger struct {
        logger *log.Logger
        level  string
}

// NewLogger creates a new logger with the specified prefix
func NewLogger(prefix string) *Logger <span class="cov9" title="18">{
        level := getLogLevel()

        var out io.Writer = os.Stderr
        if level == LogLevelSilent </span><span class="cov4" title="3">{
                out = io.Discard
        }</span>

        <span class="cov9" title="18">return &amp;Logger{
                logger: log.New(out, prefix, log.LstdFlags|log.Lshortfile),
                level:  level,
        }</span>
}

// NewDefaultLogger creates a logger with standard settings
func NewDefaultLogger() *Logger <span class="cov7" title="9">{
        return NewLogger("[planner] ")
}</span>

// getLogLevel determines the logging level from environment variables
func getLogLevel() string <span class="cov10" title="23">{
        // Check PLANNER_SILENT first for backward compatibility
        if os.Getenv(envPlannerSilent) == "1" </span><span class="cov2" title="2">{
                return LogLevelSilent
        }</span>

        // Check PLANNER_LOG_LEVEL for explicit level
        <span class="cov9" title="21">level := strings.ToLower(os.Getenv(envPlannerLogLevel))
        switch level </span>{
        case LogLevelSilent, LogLevelInfo, LogLevelDebug:<span class="cov6" title="7">
                return level</span>
        default:<span class="cov8" title="14">
                return LogLevelInfo</span> // Default to info level
        }
}

// IsSilent returns true if logging is suppressed
func IsSilent() bool <span class="cov5" title="5">{
        return getLogLevel() == LogLevelSilent
}</span>

// Info logs an informational message
func (l *Logger) Info(format string, v ...interface{}) <span class="cov7" title="9">{
        if l.level != LogLevelSilent </span><span class="cov7" title="9">{
                _ = l.logger.Output(2, fmt.Sprintf("[INFO] "+format, v...))
        }</span>
}

// Debug logs a debug message (only when debug level is enabled)
func (l *Logger) Debug(format string, v ...interface{}) <span class="cov2" title="2">{
        if l.level == LogLevelDebug </span><span class="cov0" title="0">{
                _ = l.logger.Output(2, fmt.Sprintf("[DEBUG] "+format, v...))
        }</span>
}

// Error logs an error message
func (l *Logger) Error(format string, v ...interface{}) <span class="cov2" title="2">{
        if l.level != LogLevelSilent </span><span class="cov2" title="2">{
                _ = l.logger.Output(2, fmt.Sprintf("[ERROR] "+format, v...))
        }</span>
}

// Warn logs a warning message
func (l *Logger) Warn(format string, v ...interface{}) <span class="cov2" title="2">{
        if l.level != LogLevelSilent </span><span class="cov2" title="2">{
                _ = l.logger.Output(2, fmt.Sprintf("[WARN] "+format, v...))
        }</span>
}

// Printf provides compatibility with existing log.Logger interface
func (l *Logger) Printf(format string, v ...interface{}) <span class="cov1" title="1">{
        l.Info(format, v...)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package core

import (
        "encoding/csv"
        "fmt"
        "io"
        "os"
        "strings"
        "time"
)

const (
        // DateFormats supported date formats in CSV files (in order of preference)
        DateFormatISO   = "2006-01-02"          // ISO format: 2024-01-15
        DateFormatUS    = "01/02/2006"          // US format: 01/15/2024
        DateFormatEU    = "02/01/2006"          // EU format: 15/01/2024
        DateFormatSlash = "2006/01/02"          // Slash format: 2024/01/15
        DateFormatDot   = "02.01.2006"          // Dot format: 15.01.2024
        DateFormatSpace = "2006-01-02 15:04:05" // With time: 2024-01-15 10:30:00
)

// Error types for detailed error reporting
type ParseError struct {
        Row     int
        Column  string
        Value   string
        Message string
        Err     error
}

func (e *ParseError) Error() string <span class="cov0" title="0">{
        if e.Row &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("row %d, column '%s', value '%s': %s", e.Row, e.Column, e.Value, e.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("column '%s', value '%s': %s", e.Column, e.Value, e.Message)</span>
}

func (e *ParseError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewParseError creates a new parse error with proper wrapping
func NewParseError(row int, column, value, message string, err error) *ParseError <span class="cov0" title="0">{
        return &amp;ParseError{
                Row:     row,
                Column:  column,
                Value:   value,
                Message: message,
                Err:     err,
        }
}</span>

type ValidationError struct {
        TaskID  string
        Field   string
        Value   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("task %s, field '%s', value '%s': %s", e.TaskID, e.Field, e.Value, e.Message)
}</span>

// NewValidationError creates a new validation error
func NewValidationError(taskID, field, value, message string) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                TaskID:  taskID,
                Field:   field,
                Value:   value,
                Message: message,
        }
}</span>

// Supported date formats for parsing
var supportedDateFormats = []string{
        DateFormatISO,
        DateFormatUS,
        DateFormatEU,
        DateFormatSlash,
        DateFormatDot,
        DateFormatSpace,
}

// Reader handles reading and parsing CSV task data
type Reader struct {
        filePath    string
        logger      *Logger
        aggregator  *ErrorAggregator // Error aggregator for collecting multiple errors
        strictMode  bool             // If true, fail on any parsing error
        skipInvalid bool             // If true, skip invalid rows instead of failing
        maxMemoryMB int              // Maximum memory usage in MB for large files
}

// ReaderOptions configures the CSV reader behavior
type ReaderOptions struct {
        StrictMode  bool
        SkipInvalid bool
        MaxMemoryMB int
        Logger      *Logger
}

// DefaultReaderOptions returns sensible defaults for the reader
func DefaultReaderOptions() *ReaderOptions <span class="cov5" title="8">{
        return &amp;ReaderOptions{
                StrictMode:  false,
                SkipInvalid: true,
                MaxMemoryMB: 100, // 100MB default limit
                Logger:      NewDefaultLogger(),
        }
}</span>

// NewReader creates a new CSV data reader with default options
func NewReader(filePath string) *Reader <span class="cov5" title="8">{
        opts := DefaultReaderOptions()
        return &amp;Reader{
                filePath:    filePath,
                logger:      opts.Logger,
                aggregator:  NewErrorAggregator(),
                strictMode:  opts.StrictMode,
                skipInvalid: opts.SkipInvalid,
                maxMemoryMB: opts.MaxMemoryMB,
        }
}</span>

// parseDate attempts to parse a date string using multiple supported formats
func (r *Reader) parseDate(dateStr string) (time.Time, error) <span class="cov6" title="15">{
        if dateStr == "" </span><span class="cov0" title="0">{
                return time.Time{}, NewParseError(0, "Date", dateStr, "empty date string", nil)
        }</span>

        // Clean the date string
        <span class="cov6" title="15">dateStr = strings.TrimSpace(dateStr)

        // Try each supported format
        for _, format := range supportedDateFormats </span><span class="cov6" title="17">{
                if parsed, err := time.Parse(format, dateStr); err == nil </span><span class="cov6" title="15">{
                        return parsed, nil
                }</span>
        }

        <span class="cov0" title="0">return time.Time{}, NewParseError(0, "Date", dateStr,
                fmt.Sprintf("unable to parse with any supported format (tried: %v)", supportedDateFormats), nil)</span>
}

// isMilestoneTask determines if a task is a milestone based on its name or description
func (r *Reader) isMilestoneTask(name, description string) bool <span class="cov5" title="8">{
        text := strings.ToLower(name + " " + description)
        milestoneKeywords := []string{"milestone", "deadline", "due", "complete", "finish", "submit", "deliver"}

        for _, keyword := range milestoneKeywords </span><span class="cov8" title="53">{
                if strings.Contains(text, keyword) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov4" title="7">return false</span>
}

// addError adds an error to the aggregator
func (r *Reader) addError(err error) <span class="cov0" title="0">{
        r.aggregator.AddError(err)
}</span>

// addWarning adds a warning to the aggregator
func (r *Reader) addWarning(err error) <span class="cov0" title="0">{
        r.aggregator.AddWarning(err)
}</span>

// clearErrors clears all collected errors
func (r *Reader) clearErrors() <span class="cov4" title="7">{
        r.aggregator.Clear()
}</span>

// hasErrors returns true if there are any collected errors
func (r *Reader) hasErrors() bool <span class="cov0" title="0">{
        return r.aggregator.HasErrors()
}</span>

// getErrorSummary returns a summary of all errors
func (r *Reader) getErrorSummary() string <span class="cov0" title="0">{
        return r.aggregator.Summary()
}</span>

// ReadTasks reads all tasks from the CSV file with improved error handling and memory management
func (r *Reader) ReadTasks() ([]Task, error) <span class="cov4" title="7">{
        // Clear any previous errors
        r.clearErrors()

        // Open and validate file
        file, fileInfo, err := r.openAndValidateFile()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov4" title="6">defer file.Close()

        // Check file size for memory management
        r.checkFileSize(fileInfo)

        // Create CSV reader with configuration
        csvReader := r.createCSVReader(file)

        // Read and parse header
        fieldIndex, err := r.readHeader(csvReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse all task records
        <span class="cov4" title="6">tasks, parseErrors := r.parseAllRecords(csvReader, fieldIndex)

        // Check for fatal errors (strict mode or non-skippable errors)
        if len(parseErrors) &gt; 0 &amp;&amp; (r.strictMode || !r.skipInvalid) </span><span class="cov0" title="0">{
                return tasks, parseErrors[0] // Return first error
        }</span>

        // Log parsing summary
        <span class="cov4" title="6">r.logParsingSummary(tasks, parseErrors)

        return tasks, nil</span>
}

// openAndValidateFile opens the CSV file and returns file info
func (r *Reader) openAndValidateFile() (*os.File, os.FileInfo, error) <span class="cov4" title="7">{
        file, err := os.Open(r.filePath)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return nil, nil, fmt.Errorf("CSV file not found: %s\n\nSuggestions:\n  1. Check the file path is correct\n  2. Verify the file exists in the input_data/ directory\n  3. Set PLANNER_CSV_FILE environment variable", r.filePath)
                }</span>
                <span class="cov0" title="0">if os.IsPermission(err) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("permission denied accessing CSV file: %s\n\nSuggestions:\n  1. Check file permissions\n  2. Run with appropriate user privileges\n  3. Verify the file is not locked by another program", r.filePath)
                }</span>
                <span class="cov0" title="0">return nil, nil, fmt.Errorf("failed to open CSV file %s: %w", r.filePath, err)</span>
        }

        <span class="cov4" title="6">fileInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov4" title="6">return file, fileInfo, nil</span>
}

// checkFileSize logs a warning if file size exceeds memory limit
func (r *Reader) checkFileSize(fileInfo os.FileInfo) <span class="cov4" title="6">{
        fileSizeMB := fileInfo.Size() / (1024 * 1024)
        if fileSizeMB &gt; int64(r.maxMemoryMB) </span><span class="cov0" title="0">{
                r.logger.Warn("File size %dMB exceeds limit %dMB, consider using streaming mode", fileSizeMB, r.maxMemoryMB)
        }</span>
}

// createCSVReader creates a configured CSV reader
func (r *Reader) createCSVReader(file *os.File) *csv.Reader <span class="cov4" title="6">{
        reader := csv.NewReader(file)
        reader.FieldsPerRecord = -1    // Allow variable number of fields
        reader.TrimLeadingSpace = true // Trim leading spaces
        return reader
}</span>

// readHeader reads the CSV header and creates field index map
func (r *Reader) readHeader(reader *csv.Reader) (map[string]int, error) <span class="cov4" title="6">{
        header, err := reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV header: %w", err)
        }</span>

        <span class="cov4" title="6">return r.createFieldIndexMap(header), nil</span>
}

// createFieldIndexMap creates a case-insensitive field index map
func (r *Reader) createFieldIndexMap(header []string) map[string]int <span class="cov4" title="6">{
        fieldIndex := make(map[string]int)
        for i, field := range header </span><span class="cov7" title="23">{
                normalizedField := strings.ToLower(strings.TrimSpace(field))
                fieldIndex[normalizedField] = i
        }</span>
        <span class="cov4" title="6">return fieldIndex</span>
}

// parseAllRecords parses all CSV records into tasks
func (r *Reader) parseAllRecords(reader *csv.Reader, fieldIndex map[string]int) ([]Task, []error) <span class="cov4" title="6">{
        var tasks []Task
        var parseErrors []error
        rowNum := 1 // Start from 1 (header is row 0)

        for </span><span class="cov6" title="14">{
                record, err := reader.Read()
                if err == io.EOF </span><span class="cov4" title="6">{
                        break</span>
                }
                <span class="cov5" title="8">if err != nil </span><span class="cov0" title="0">{
                        parseErrors = append(parseErrors, fmt.Errorf("row %d: %w", rowNum, err))
                        r.addError(fmt.Errorf("row %d: %w", rowNum, err))
                        break</span>
                }

                <span class="cov5" title="8">rowNum++

                // Skip empty rows
                if len(record) == 0 || record[0] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="8">task, err := r.parseTask(record, fieldIndex, rowNum)
                if err != nil </span><span class="cov0" title="0">{
                        parseErr := fmt.Errorf("row %d: %w", rowNum, err)
                        parseErrors = append(parseErrors, parseErr)
                        r.addError(parseErr)

                        if r.strictMode </span><span class="cov0" title="0">{
                                // Return error immediately in strict mode
                                return tasks, []error{fmt.Errorf("strict mode: failed to parse task at row %d: %w", rowNum, err)}
                        }</span>

                        <span class="cov0" title="0">if !r.skipInvalid </span><span class="cov0" title="0">{
                                // Return error if not skipping invalid rows
                                return tasks, []error{fmt.Errorf("failed to parse task at row %d: %w", rowNum, err)}
                        }</span>

                        // Log warning but continue processing other tasks
                        <span class="cov0" title="0">r.logger.Warn("Skipping invalid task at row %d: %v", rowNum, err)
                        r.addWarning(fmt.Errorf("skipped invalid task at row %d: %w", rowNum, err))
                        continue</span>
                }

                <span class="cov5" title="8">tasks = append(tasks, task)</span>
        }

        <span class="cov4" title="6">return tasks, parseErrors</span>
}

// logParsingSummary logs a summary of the parsing results
func (r *Reader) logParsingSummary(tasks []Task, _ []error) <span class="cov4" title="6">{
        errorCount := r.aggregator.ErrorCount()
        warningCount := r.aggregator.WarningCount()

        if errorCount == 0 &amp;&amp; warningCount == 0 </span><span class="cov4" title="6">{
                r.logger.Info("Successfully parsed %d tasks with no issues", len(tasks))
                return
        }</span>

        <span class="cov0" title="0">if errorCount &gt; 0 &amp;&amp; warningCount &gt; 0 </span><span class="cov0" title="0">{
                r.logger.Info("Parsed %d tasks with %d errors and %d warnings", len(tasks), errorCount, warningCount)
        }</span> else<span class="cov0" title="0"> if errorCount &gt; 0 </span><span class="cov0" title="0">{
                r.logger.Info("Parsed %d tasks with %d errors", len(tasks), errorCount)
        }</span> else<span class="cov0" title="0"> {
                r.logger.Info("Parsed %d tasks with %d warnings", len(tasks), warningCount)
        }</span>

        <span class="cov0" title="0">if r.hasErrors() || r.aggregator.HasWarnings() </span><span class="cov0" title="0">{
                r.logger.Warn("Parsing details:\n%s", r.getErrorSummary())
        }</span>
}

// fieldExtractor helps extract fields from CSV records with case-insensitive matching
type fieldExtractor struct {
        record     []string
        fieldIndex map[string]int
}

// newFieldExtractor creates a new field extractor
func newFieldExtractor(record []string, fieldIndex map[string]int) *fieldExtractor <span class="cov5" title="8">{
        return &amp;fieldExtractor{
                record:     record,
                fieldIndex: fieldIndex,
        }
}</span>

// get retrieves a field value by name (case-insensitive)
func (fe *fieldExtractor) get(fieldName string) string <span class="cov10" title="104">{
        normalizedField := strings.ToLower(strings.TrimSpace(fieldName))
        if index, exists := fe.fieldIndex[normalizedField]; exists &amp;&amp; index &lt; len(fe.record) </span><span class="cov7" title="36">{
                return strings.TrimSpace(fe.record[index])
        }</span>
        <span class="cov9" title="68">return ""</span>
}

// getWithDefault retrieves a field value with a default fallback
func (fe *fieldExtractor) getWithDefault(fieldName, defaultValue string) string <span class="cov5" title="8">{
        value := fe.get(fieldName)
        if value == "" </span><span class="cov4" title="7">{
                return defaultValue
        }</span>
        <span class="cov1" title="1">return value</span>
}

// getList retrieves a comma-separated list field as a slice
func (fe *fieldExtractor) getList(fieldName string) []string <span class="cov5" title="8">{
        value := fe.get(fieldName)
        if value == "" </span><span class="cov5" title="8">{
                return nil
        }</span>

        <span class="cov0" title="0">var result []string
        parts := strings.Split(value, ",")
        for _, part := range parts </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(part)
                if trimmed != "" </span><span class="cov0" title="0">{
                        result = append(result, trimmed)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// parseTask parses a single CSV record into a Task struct with improved field mapping
func (r *Reader) parseTask(record []string, fieldIndex map[string]int, rowNum int) (Task, error) <span class="cov5" title="8">{
        extractor := newFieldExtractor(record, fieldIndex)
        task := Task{}

        // Extract basic fields
        r.extractBasicFields(&amp;task, extractor)

        // Extract phase and category
        r.extractPhaseFields(&amp;task, extractor)

        // Extract status and assignment
        r.extractStatusFields(&amp;task, extractor)

        // Extract dependencies
        task.Dependencies = extractor.getList("Dependencies")

        // Parse dates
        if err := r.extractDateFields(&amp;task, extractor, rowNum); err != nil </span><span class="cov0" title="0">{
                return task, err
        }</span>

        // Validate dates
        <span class="cov5" title="8">if err := r.validateDates(task); err != nil </span><span class="cov0" title="0">{
                return task, err
        }</span>

        <span class="cov5" title="8">return task, nil</span>
}

// extractBasicFields extracts ID, name, description, and milestone status
func (r *Reader) extractBasicFields(task *Task, extractor *fieldExtractor) <span class="cov5" title="8">{
        task.ID = extractor.get("Task ID")
        if task.ID == "" </span><span class="cov5" title="8">{
                task.ID = extractor.get("Task") // Fallback to name if no ID
        }</span>
        <span class="cov5" title="8">task.Name = extractor.get("Task")
        task.Description = extractor.get("Objective")

        // Extract milestone status from CSV column or detect from content
        milestoneValue := extractor.get("Milestone")
        if milestoneValue != "" &amp;&amp; strings.ToLower(milestoneValue) != "false" </span><span class="cov0" title="0">{
                task.IsMilestone = true
        }</span> else<span class="cov5" title="8"> {
                // Fallback to keyword detection
                task.IsMilestone = r.isMilestoneTask(task.Name, task.Description)
        }</span>
}

// extractPhaseFields extracts phase and category information
func (r *Reader) extractPhaseFields(task *Task, extractor *fieldExtractor) <span class="cov5" title="8">{
        task.Phase = extractor.get("Phase")
        task.SubPhase = extractor.get("Sub-Phase")

        // Use Sub-Phase as primary category for better granularity
        task.Category = task.SubPhase
        if task.Category == "" </span><span class="cov5" title="8">{
                task.Category = task.Phase // Fallback to Phase if Sub-Phase is empty
        }</span>
}

// extractStatusFields extracts status and assignee
func (r *Reader) extractStatusFields(task *Task, extractor *fieldExtractor) <span class="cov5" title="8">{
        task.Status = extractor.getWithDefault("Status", "Planned")
        task.Assignee = extractor.get("Assignee")
        task.ParentID = extractor.get("Parent Task ID")
}</span>

// extractDateFields parses date fields from the extractor
func (r *Reader) extractDateFields(task *Task, extractor *fieldExtractor, rowNum int) error <span class="cov5" title="8">{
        startDateStr := extractor.get("Start Date")
        if startDateStr != "" </span><span class="cov5" title="8">{
                startDate, err := r.parseDate(startDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return NewParseError(rowNum, "Start Date", startDateStr, "invalid date format", err)
                }</span>
                <span class="cov5" title="8">task.StartDate = startDate</span>
        }

        <span class="cov5" title="8">endDateStr := extractor.get("End Date")
        if endDateStr != "" </span><span class="cov4" title="7">{
                endDate, err := r.parseDate(endDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return NewParseError(rowNum, "End Date", endDateStr, "invalid date format", err)
                }</span>
                <span class="cov4" title="7">task.EndDate = endDate</span>
        }

        <span class="cov5" title="8">return nil</span>
}

// validateDates validates that end date is not before start date
func (r *Reader) validateDates(task Task) error <span class="cov5" title="8">{
        if !task.StartDate.IsZero() &amp;&amp; !task.EndDate.IsZero() &amp;&amp; task.EndDate.Before(task.StartDate) </span><span class="cov0" title="0">{
                return NewValidationError(
                        task.ID,
                        "Due Date",
                        task.EndDate.Format("2006-01-02"),
                        fmt.Sprintf("end date %s is before start date %s",
                                task.EndDate.Format("2006-01-02"),
                                task.StartDate.Format("2006-01-02")),
                )
        }</span>
        <span class="cov5" title="8">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import (
        "fmt"
        "strings"
        "time"
)

// Task represents a single task from the CSV data
type Task struct {
        ID           string // * Added: Unique task identifier
        Name         string
        StartDate    time.Time
        EndDate      time.Time
        Phase        string // * Added: Phase (1, 2, 3, 4)
        SubPhase     string // * Added: Sub-Phase (detailed phase description)
        Category     string // * Fixed: Use Category instead of Priority for clarity
        Description  string
        Status       string   // * Added: Task status (Planned, In Progress, Completed, etc.)
        Assignee     string   // * Added: Task assignee
        ParentID     string   // * Added: Parent task ID for hierarchical relationships
        Dependencies []string // * Added: List of task IDs this task depends on
        IsMilestone  bool     // * Added: Whether this is a milestone task
}

// DateRange represents the earliest and latest dates from the task data
type DateRange struct {
        Earliest time.Time
        Latest   time.Time
}

// MonthYear represents a specific month and year
type MonthYear struct {
        Year  int
        Month time.Month
}

// TaskCategory represents a task category with visual and organizational properties
type TaskCategory struct {
        Name        string
        DisplayName string
        Color       string
        Description string
}

// Predefined task categories with their properties
var (
        CategoryPROPOSAL = TaskCategory{
                Name:        "PROPOSAL",
                DisplayName: "Proposal",
                Color:       GenerateCategoryColor("PROPOSAL"),
                Description: "PhD proposal related tasks",
        }

        CategoryLASER = TaskCategory{
                Name:        "LASER",
                DisplayName: "Laser System",
                Color:       GenerateCategoryColor("LASER"),
                Description: "Laser system setup and maintenance",
        }

        CategoryIMAGING = TaskCategory{
                Name:        "IMAGING",
                DisplayName: "Imaging",
                Color:       GenerateCategoryColor("IMAGING"),
                Description: "Imaging experiments and data collection",
        }

        CategoryADMIN = TaskCategory{
                Name:        "ADMIN",
                DisplayName: "Administrative",
                Color:       GenerateCategoryColor("ADMIN"),
                Description: "Administrative tasks and paperwork",
        }

        CategoryDISSERTATION = TaskCategory{
                Name:        "DISSERTATION",
                DisplayName: "Dissertation",
                Color:       GenerateCategoryColor("DISSERTATION"),
                Description: "Dissertation writing and defense",
        }

        CategoryRESEARCH = TaskCategory{
                Name:        "RESEARCH",
                DisplayName: "Research",
                Color:       GenerateCategoryColor("RESEARCH"),
                Description: "General research activities",
        }

        CategoryPUBLICATION = TaskCategory{
                Name:        "PUBLICATION",
                DisplayName: "Publication",
                Color:       GenerateCategoryColor("PUBLICATION"),
                Description: "Publication and manuscript writing",
        }
)

// GenerateCategoryColor creates a consistent, visually distinct color based on the category name
func GenerateCategoryColor(category string) string <span class="cov5" title="7">{
        // Dynamic color assignment using golden angle for maximum visual distinction
        // This ensures each unique category gets a unique, well-distributed color

        // Normalize category name for consistency
        normalizedCategory := strings.ToUpper(strings.TrimSpace(category))

        // Create a hash of the category name for consistent color assignment
        hash := 0
        for i, char := range normalizedCategory </span><span class="cov10" title="56">{
                hash = hash*31 + int(char) + i*7 // Improved hash distribution
        }</span>
        <span class="cov5" title="7">if hash &lt; 0 </span><span class="cov0" title="0">{
                hash = -hash
        }</span>

        // Use golden angle approximation (137.5 degrees) for optimal color distribution
        // This spreads colors evenly around the color wheel
        <span class="cov5" title="7">hue := float64(hash%360) * 137.5
        hue = hue - float64(int(hue/360.0)*360) // Keep hue in 0-360 range

        // Optimized saturation and lightness for accessibility and visual appeal
        saturation := 0.75 // High saturation for vibrancy
        lightness := 0.65  // Balanced lightness for good contrast

        // Convert HSL to RGB
        r, g, b := hslToRgb(hue, saturation, lightness)

        // Convert to hex
        return fmt.Sprintf("#%02X%02X%02X", r, g, b)</span>
}

// hslToRgb converts HSL color values to RGB
func hslToRgb(h, s, l float64) (int, int, int) <span class="cov5" title="7">{
        // Normalize values
        h = h / 360.0

        var r, g, b float64

        if s == 0 </span><span class="cov0" title="0">{
                // Grayscale
                r, g, b = l, l, l
        }</span> else<span class="cov5" title="7"> {
                var q, p float64
                if l &lt; 0.5 </span><span class="cov0" title="0">{
                        q = l * (1 + s)
                }</span> else<span class="cov5" title="7"> {
                        q = l + s - l*s
                }</span>
                <span class="cov5" title="7">p = 2*l - q

                r = hueToRgb(p, q, h+1.0/3.0)
                g = hueToRgb(p, q, h)
                b = hueToRgb(p, q, h-1.0/3.0)</span>
        }

        <span class="cov5" title="7">return int(r * 255), int(g * 255), int(b * 255)</span>
}

// hueToRgb helper function for HSL to RGB conversion
func hueToRgb(p, q, t float64) float64 <span class="cov7" title="21">{
        if t &lt; 0 </span><span class="cov4" title="4">{
                t += 1
        }</span>
        <span class="cov7" title="21">if t &gt; 1 </span><span class="cov1" title="1">{
                t -= 1
        }</span>
        <span class="cov7" title="21">if t &lt; 1.0/6.0 </span><span class="cov4" title="5">{
                return p + (q-p)*6*t
        }</span>
        <span class="cov7" title="16">if t &lt; 1.0/2.0 </span><span class="cov5" title="7">{
                return q
        }</span>
        <span class="cov5" title="9">if t &lt; 2.0/3.0 </span><span class="cov2" title="2">{
                return p + (q-p)*(2.0/3.0-t)*6
        }</span>
        <span class="cov5" title="7">return p</span>
}

// GetCategory returns the TaskCategory for a given category name
// GetAllCategories returns all predefined categories
// TaskRenderer represents visual rendering properties for tasks
type TaskRenderer struct {
        TaskID      string
        X           float64 // X position in calendar
        Y           float64 // Y position in calendar
        Width       float64 // Width in calendar
        Height      float64 // Height in calendar
        Color       string  // Task color
        BorderColor string  // Border color
        Opacity     float64 // Opacity (0.0 to 1.0)
        Visible     bool    // Whether task is visible
}

// Enhanced Task methods for calendar layout and rendering
</pre>
		
		<pre class="file" id="file14" style="display: none">package templates

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

const nl = "\n"

// LaTeX Functions

// CellColor creates a colored cell
func CellColor(color, text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\cellcolor{%s}{%s}`, color, text)
}</span>

// TextColor creates colored text
func TextColor(color, text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\textcolor{%s}{%s}`, color, text)
}</span>

// Hyperlink creates a hyperlink
func Hyperlink(ref, text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\hyperlink{%s}{%s}`, ref, text)
}</span>

// Hypertarget creates a hypertarget
func Hypertarget(ref, text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\hypertarget{%s}{%s}`, ref, text)
}</span>

// Tabular creates a tabular environment
func Tabular(format, text string) string <span class="cov0" title="0">{
        return `\begin{tabular}{` + format + `}` + nl + text + nl + `\end{tabular}`
}</span>

// ResizeBoxW creates a resized box with specified width
func ResizeBoxW(width, text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\resizebox{!}{%s}{%s}`, width, text)
}</span>

// Multirow creates a multirow cell
func Multirow(rows int, text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\multirow{%d}{*}{%s}`, rows, text)
}</span>

// Bold creates bold text
func Bold(text string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`\textbf{%s}`, text)
}</span>

// Target creates a target for hyperlinks
func Target(ref, text string) string <span class="cov0" title="0">{
        return "\\hypertarget{" + ref + "}{" + text + "}"
}</span>

// Link creates a hyperlink
func Link(ref, text string) string <span class="cov0" title="0">{
        return "\\hyperlink{" + ref + "}{" + text + "}"
}</span>

// EmphCell creates an emphasized cell with black background and white text
func EmphCell(text string) string <span class="cov0" title="0">{
        return CellColor("black", TextColor("white", text))
}</span>

// Header Items

// Item interface defines the contract for all header items
type Item interface {
        Display() string
}

// Items is a slice of Item interfaces
type Items []Item

// plainItem creates a simple item that just displays the given text
type plainItem string

func (p plainItem) Display() string <span class="cov0" title="0">{
        return string(p)
}</span>

// ItemsGroup groups multiple items with a delimiter
type ItemsGroup struct {
        Items Items
}

// IntItem represents an integer item with optional reference
type IntItem struct {
        Val int
        ref bool
}

func (i IntItem) Display() string <span class="cov0" title="0">{
        var out string
        s := strconv.Itoa(i.Val)

        if i.ref </span><span class="cov0" title="0">{
                out = Target(s, s)
        }</span> else<span class="cov0" title="0"> {
                out = Link(s, s)
        }</span>

        <span class="cov0" title="0">return out</span>
}

func (i IntItem) Ref() IntItem <span class="cov0" title="0">{
        i.ref = true
        return i
}</span>

func NewIntItem(val int) IntItem <span class="cov0" title="0">{
        return IntItem{Val: val}
}</span>

// MonthItem represents a month item with optional reference and shortening
type MonthItem struct {
        Val     time.Month
        ref     bool
        shorten bool
}

func (m MonthItem) Display() string <span class="cov0" title="0">{
        ref := m.Val.String()
        text := ref

        if m.shorten </span><span class="cov0" title="0">{
                text = text[:3]
        }</span>

        <span class="cov0" title="0">if m.ref </span><span class="cov0" title="0">{
                return Target(ref, text)
        }</span>

        <span class="cov0" title="0">return Link(ref, text)</span>
}

func (m MonthItem) Ref() MonthItem <span class="cov0" title="0">{
        m.ref = true
        return m
}</span>

func (m MonthItem) Shorten(f bool) MonthItem <span class="cov0" title="0">{
        m.shorten = f
        return m
}</span>

func NewMonthItem(mo time.Month) MonthItem <span class="cov0" title="0">{
        return MonthItem{Val: mo}
}</span>

// CellItem represents a cell item with text and reference
type CellItem struct {
        Text string
        Ref  string
}

// TextItem represents a text item with formatting and reference options
type TextItem struct {
        Name      string
        bold      bool
        ref       bool
        refPrefix string
        refText   string
}

func NewTextItem(name string) TextItem <span class="cov0" title="0">{
        return TextItem{
                Name: name,
        }
}</span>

func (t TextItem) Display() string <span class="cov0" title="0">{
        var (
                out string
                ref string
        )
        if t.bold </span><span class="cov0" title="0">{
                out = "\\textbf{" + t.Name + "}"
        }</span> else<span class="cov0" title="0"> {
                out = t.Name
        }</span>

        <span class="cov0" title="0">if len(t.refText) &gt; 0 </span><span class="cov0" title="0">{
                ref = t.refText
        }</span> else<span class="cov0" title="0"> {
                ref = t.refPrefix + t.Name
        }</span>

        <span class="cov0" title="0">if t.ref </span><span class="cov0" title="0">{
                return Target(ref, out)
        }</span>

        <span class="cov0" title="0">return Link(ref, out)</span>
}

func (t TextItem) Ref(ref bool) TextItem <span class="cov0" title="0">{
        t.ref = ref
        return t
}</span>

func (t TextItem) Bold(f bool) TextItem <span class="cov0" title="0">{
        t.bold = f
        return t
}</span>

func (t TextItem) RefPrefix(refPrefix string) TextItem <span class="cov0" title="0">{
        t.refPrefix = refPrefix
        return t
}</span>

func (t TextItem) RefText(refText string) TextItem <span class="cov0" title="0">{
        t.refText = refText
        return t
}</span>

// Items methods for working with collections of items

func (i Items) WithTopRightCorner(flag bool, kernSpacing string) Items <span class="cov0" title="0">{
        if !flag </span><span class="cov0" title="0">{
                return i
        }</span>

        <span class="cov0" title="0">return append(i, plainItem(`\kern `+kernSpacing))</span>
}

func (i Items) Length() int <span class="cov0" title="0">{
        return len(i)
}</span>

func (i Items) ColSetup(left bool) string <span class="cov0" title="0">{
        if left </span><span class="cov0" title="0">{
                return "|" + strings.Join(strings.Split(strings.Repeat("l", len(i)), ""), "|")
        }</span>

        <span class="cov0" title="0">return strings.Join(strings.Split(strings.Repeat("r", len(i)), ""), "|") + "@{}"</span>
}

func (i Items) Row() string <span class="cov0" title="0">{
        out := make([]string, 0, len(i))

        for _, item := range i </span><span class="cov0" title="0">{
                out = append(out, item.Display())
        }</span>

        <span class="cov0" title="0">return strings.Join(out, " &amp; ")</span>
}

func (i Items) Table(left bool) string <span class="cov0" title="0">{
        if len(i) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return `\begin{tabular}{` + i.ColSetup(left) + `}
` + i.Row() + `
\end{tabular}`</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
